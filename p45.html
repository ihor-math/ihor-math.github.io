<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>45. Обчислення кута між прямими</title>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            startup: {
                ready: () => {
                    console.log("MathJax is loaded and ready!");
                    MathJax.startup.defaultReady();
                }
            }
        };
    </script>
   
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Roboto+Condensed:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        *, *:before, *:after { box-sizing: border-box; }
body {
    margin: 0;
    background: radial-gradient(circle at center, #0a0a0a 0%, #1a1a1a 40%, #2b2b2b 100%);
    color: #e0e0e0;
    font-family: 'Roboto Condensed', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    min-height: 100vh;
    visibility: hidden;
    opacity: 0;
    transition: opacity 0.4s ease;
}
body.loaded { visibility: visible; opacity: 1; }

/* Заголовок */
.title-box {
    margin-top: 60px;
    padding: 20px 40px;
    background: linear-gradient(135deg, #1c2526, #2e3a3b);
    box-shadow: 0 6px 20px rgba(0,0,0,0.6);
    border-radius: 16px;
    max-width: 90%;
    text-align: center;
    border: 1px solid #3e4a4b;
}
.title-box h1 {
    margin: 0;
    font-size: 28px;
    color: #ff4d4d;
    font-family: 'Orbitron', sans-serif;
    text-shadow: 0 0 8px rgba(255,77,77,0.5);
}

/* Картки розділів */
.section-container {
    margin-top: 40px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 25px;
}
.section {
    width: 260px;
    height: 200px;
    background: linear-gradient(145deg, #1e2a2b, #2c3e40);
    border-radius: 14px;
    box-shadow: 0 6px 16px rgba(0,0,0,0.45);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 15px;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    cursor: pointer;
    border: 1px solid rgba(255,77,77,0.15);
}
.section:hover {
    transform: scale(1.06);
    box-shadow: 0 10px 25px rgba(255,77,77,0.25);
    background: linear-gradient(145deg, #253435, #334c4e);
}
.section h2 {
    font-size: 20px;
    color: #ffffff;
    font-family: 'Orbitron', sans-serif;
}
.section img {
    width: 60px;
    height: 60px;
    margin-bottom: 15px;
    object-fit: cover;
    border-radius: 8px;
    filter: brightness(1.3) drop-shadow(0 0 6px #ff4d4d);
}

/* Модальні вікна */
.modal {
    display: none;
    position: fixed;
    top: 5%;
    left: 5%;
    width: 90%;
    height: 90%;
    background: linear-gradient(135deg, #2b3a3b, #3e5c5e);
    border-radius: 15px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.4);
    z-index: 1001;
    overflow: hidden;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    border: 1px solid rgba(255,77,77,0.2);
}
#modalOverlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    z-index: 999;
    backdrop-filter: blur(5px);
}
.modal-content {
    padding: 20px;
    flex-grow: 1;
    background: #2b3a3b;
    border-radius: 10px;
    margin: 10px;
    color: #e0e0e0;
    width: calc(100% - 20px);
    overflow-y: auto;
    display: block;
    max-height: calc(100% - 60px);
}
.modal-content::-webkit-scrollbar {
    width: 6px;
}
.modal-content::-webkit-scrollbar-track {
    background: transparent;
}
.modal-content::-webkit-scrollbar-thumb {
    background: linear-gradient(45deg, #6a5acd, #9370db);
    border-radius: 3px;
}
.modal-content::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(45deg, #483d8b, #7b68ee);
}
.modal-header {
    background: linear-gradient(0deg, #2b3a3b, #3e5c5e);
    padding: 8px 12px;
    display: flex;
    justify-content: flex-end;
    width: 100%;
    flex-shrink: 0;
    position: sticky;
    top: 0;
    z-index: 1002;
    border-top-left-radius: 15px;
    border-top-right-radius: 15px;
    border-bottom: 1px solid rgba(255,77,77,0.2);
}
.close-btn {
    background: linear-gradient(135deg, #c1121f, #e63946);
    color: #ffffff;
    border: none;
    border-radius: 6px;
    padding: 6px 16px;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: 'Orbitron', sans-serif;
    box-shadow: 0 2px 8px rgba(193,18,31,0.4);
}
.close-btn:hover {
    background: linear-gradient(135deg, #780000, #c1121f);
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(193,18,31,0.5);
}

/* Теорія */
.theory-content h2 {
    color: #ff4d4d;
    text-align: center;
    text-shadow: 0 0 10px rgba(255,77,77,0.5);
    margin-bottom: 20px;
    font-family: 'Orbitron', sans-serif;
    font-size: 28px;
}
.theory-content p, .theory-content li {
    color: #e0e0e0;
    font-size: clamp(18px, 3vw, 20px);
    line-height: 1.7;
    text-align: justify;
}
.example {
    background: rgba(255,77,77,0.1);
    border-left: 4px solid #ff4d4d;
    padding: 12px;
    margin: 15px 0;
    border-radius: 6px;
    font-weight: bold;
    color: #ff9999;
}
.solution {
    background: rgba(255,77,77,0.15);
    border: 2px solid #ff4d4d;
    padding: 10px;
    margin: 15px 0;
    border-radius: 6px;
    text-align: center;
    color: #ff4d4d;
    font-weight: bold;
}
.math-notation-centered {
    display: block;
    text-align: center;
    font-size: clamp(18px, 3vw, 20px);
    margin: 12px 0;
    color: #ffff99;
}
mjx-container {
    color: #ffff99 !important;
    font-style: italic !important;
    font-size: 20px !important;
}
.theory-content mjx-container {
    color: #ffff99 !important;
    font-size: 18px !important;
}

/* Відео */
.video-card-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin-top: 20px;
}
.video-card {
    width: 350px;
    height: 250px;
    background: linear-gradient(135deg, #1e3a5f, #0f3460);
    border-radius: 15px;
    border: 1px solid rgba(0, 212, 255, 0.3);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 10px;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    cursor: pointer;
    color: #e8e8e8;
    position: relative;
    overflow: hidden;
}
.video-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(0, 212, 255, 0.1), transparent);
    transition: left 0.5s;
}
.video-card:hover::before {
    left: 100%;
}
.video-card:hover {
    transform: scale(1.05);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
}
.video-card img {
    width: 40px;
    height: 40px;
    margin-bottom: 8px;
    object-fit: cover;
    border-radius: 6px;
}
.video-card h3 {
    font-size: clamp(16px, 2.5vw, 18px);
    font-weight: 600;
}
.video-player-container {
    max-width: 95%;
    margin: 0 auto;
}
.video-player-container iframe {
    width: 100%;
    aspect-ratio: 16 / 9;
    height: auto;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

/* Питання і відповіді */
/* Питання і відповіді - ВИПРАВЛЕННЯ */
.question-card {
    perspective: 1000px;
    margin: 20px auto;
    max-width: 964px;
    width: 100%;
    min-height: 150px;
    cursor: pointer;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
}

.card-inner {
    position: relative;
    width: 100%;
    min-height: 200px;
    transition: transform 0.6s ease;
    transform-style: preserve-3d;
}

.question-card.flipped .card-inner { 
    transform: rotateY(180deg); 
}

.card-front, .card-back {
    position: absolute;
    width: 100%;
    height: 100%;
    min-height: 200px;
    backface-visibility: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 6px 15px rgba(0,0,0,0.4);
    text-align: center;
    border: 1px solid rgba(255,77,77,0.3);
    top: 0;
    left: 0;
}

.card-front {
    background: linear-gradient(135deg, #1c2526, #2e3a3b);
    color: #ffffff;
}

.card-back {
    background: linear-gradient(135deg, #2b3a3b, #3e5c5e);
    color: #e0e0e0;
    transform: rotateY(180deg);
    text-align: justify;
    padding: 25px;
    overflow-y: auto;
}

.card-front span, .card-back span {
    font-size: clamp(17px, 3vw, 19px);
    line-height: 1.5;
    font-weight: 500;
}

#questionsModal mjx-container { 
    color: #ffff99 !important; 
    font-style: normal !important; 
    font-weight: 500 !important; 
}

/* Додаткові покращення для кращої роботи */
.question-card:active {
    transform: scale(0.98);
    transition: transform 0.1s ease;
}

/* Запобігаємо виділенню тексту при кліку */
.question-card {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

/* Покращуємо видимість меж карток */
#questionsModal .modal-content {
    padding: 15px;
}



/* Тренажер */
.trainer-container {
    width: 98%;
    max-width: 900px;
    padding: 2vw 3vw;
    text-align: center;
    background: linear-gradient(135deg, #1c1c1c, #2a2a2a);
    border-radius: 16px;
    box-shadow: 0 4px 20px rgba(255,77,77,0.15);
    margin: auto;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    min-height: 100%;
    border: 1px solid rgba(255,77,77,0.2);
}
    #trainerModal .modal-content {
    padding: 15px !important;
}
.question-circle {
    width: clamp(80px, 15vw, 120px);
    height: clamp(80px, 15vw, 120px);
    margin: 0 auto 3vw;
    background: linear-gradient(135deg, #c1121f, #e63946);
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 4px 12px rgba(193,18,31,0.4);
}
.question-circle h3 {
    color: #ffffff;
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(16px, 2.5vw, 20px);
    margin: 0;
    text-shadow: 0 0 6px rgba(0,0,0,0.5);
}
.options-container {
    display: flex;
    flex-wrap: wrap;
    gap: 2vw;
    justify-content: center;
    margin-bottom: 3vw;
    width: 100%;
}
.option {
    padding: 1.5vw 3vw;
    border: 1.5px solid #c1121f;
    border-radius: 8px;
    background: linear-gradient(135deg, #2b3a3b, #3e5c5e);
    cursor: pointer;
    font-size: clamp(15px, 3.5vw, 18px);
    min-height: 45px;
    max-width: 45%;
    text-align: center;
    font-family: 'Orbitron', sans-serif;
    transition: all 0.3s ease;
    color: #e0e0e0;
    pointer-events: auto !important;
    user-select: none;
    -webkit-user-select: none;
    touch-action: manipulation;
}
.option.touched, .option:active {
    background: linear-gradient(135deg, #ff4d4d, #ff6666) !important;
    color: #fff !important;
    border: 2px solid #fff !important;
    transform: scale(0.97);
    box-shadow: 0 2px 8px rgba(193,18,31,0.5);
    transition: all 0.15s ease;
}
.option:hover {
    background: linear-gradient(135deg, #c1121f, #e63946);
    transform: scale(1.03);
    border-color: #ff4d4d;
    box-shadow: 0 4px 12px rgba(193,18,31,0.3);
}
.option.selected {
    background: linear-gradient(135deg, #ff4d4d, #ff6666) !important;
    color: #ffffff !important;
    border: 2px solid #ffffff !important;
    font-weight: bold;
}

#trainerModal mjx-container {
    color: #ffff99 !important;
    font-style: normal !important;
    font-weight: 500 !important;
    font-size: 1.2em !important;
    line-height: 1.6 !important;
}
#trainerModal #questionText mjx-container {
    font-size: 1.1em !important;
}
#trainerModal .option mjx-container {
    font-size: 1.1em !important;
}

#questionText {
    margin: 20px 0;
    text-align: center;
}
.option {
    min-height: 60px;
    padding: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}

button {
    background: linear-gradient(135deg, #c1121f, #e63946);
    color: #ffffff;
    border: none;
    border-radius: 25px;
    padding: clamp(10px, 2vw, 12px) clamp(20px, 4vw, 24px);
    font-size: clamp(16px, 3vw, 18px);
    font-family: 'Orbitron', sans-serif;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(193,18,31,0.3);
}
button:hover:not(:disabled) {
    background: linear-gradient(135deg, #780000, #c1121f);
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(193,18,31,0.4);
}
button:disabled { background: #555; cursor: not-allowed; }

.feedback {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: clamp(24px, 5.8vw, 30px);
    font-family: 'Orbitron', sans-serif;
    padding: 20px 30px;
    border-radius: 10px;
    box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    z-index: 1001;
    opacity: 0;
    transition: opacity 0.3s ease;
    text-align: center;
    border: 2px solid transparent;
}
.feedback.show { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
.correct-feedback { color: #ffffff; background: linear-gradient(135deg, #2a9d8f, #2a9d8f); border-color: #2a9d8f; }
.incorrect-feedback { color: #ffffff; background: linear-gradient(135deg, #e63946, #c1121f); border-color: #e63946; }

.completion-message {
    background: linear-gradient(135deg, #ff4d4d, #ff6666);
    border: 2.5px solid #ffffff;
    border-radius: 15px;
    padding: clamp(12px, 3vw, 18px);
    box-shadow: 0 6px 12px rgba(255,77,77,0.4);
    margin: 2vw auto;
    max-width: 90%;
    text-align: center;
}
.completion-message h2 {
    color: #ffffff;
    text-shadow: 0 0 10px rgba(0,0,0,0.5);
}
.completion-message p { color: #ffffff; }

/* Медаль з тризубом */
.completion-emoji {
    position: relative;
    display: inline-block;
    width: clamp(56px, 12vw, 96px);
    height: clamp(56px, 12vw, 96px);
    vertical-align: middle;
    margin: 0 auto 3vw;
    border-radius: 50%;
    background: linear-gradient(135deg, #1c2526, #2e3a3b);
    border: 3px dashed #ffd700;
    box-shadow: 0 4px 16px rgba(255, 215, 0, 0.3);
    overflow: hidden;
    animation: medalAppear 0.8s ease-out;
}
.completion-emoji::after {
    content: '';
    position: absolute;
    inset: 0;
    background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120'><defs><radialGradient id='goldShine' cx='40%' cy='35%' r='70%'><stop offset='0%' stop-color='%23fff59d'/><stop offset='40%' stop-color='%23ffeb3b'/><stop offset='100%' stop-color='%23f9a825'/></radialGradient><filter id='s' x='-50%' y='-50%' width='200%' height='200%'><feDropShadow dx='0' dy='2' stdDeviation='3' flood-color='%23000000' flood-opacity='0.4'/></filter></defs><rect x='30' y='0' width='60' height='40' rx='4' fill='%23007ACC'/><rect x='30' y='20' width='60' height='20' rx='4' fill='%23FFD700'/><g transform='translate(60,70)'><polygon points='0,-26 6,-6 26,-6 9,6 15,26 0,14 -15,26 -9,6 -26,-6 -6,-6' fill='url(%23goldShine)' filter='url(%23s)'/></g></svg>");
    background-size: 75%;
    background-repeat: no-repeat;
    background-position: center 60%;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.25));
    animation: medalBounce 1.2s ease-out 0.3s both;
}
@keyframes medalAppear {
    0% { transform: scale(0.3) rotate(-180deg); opacity: 0; }
    60% { transform: scale(1.1); }
    100% { transform: scale(1); opacity: 1; }
}
@keyframes medalBounce {
    0% { transform: translateY(-120px) rotate(-30deg) scale(0.4); opacity: 0; }
    60% { transform: translateY(15px) rotate(10deg) scale(1.15); opacity: 1; }
    80% { transform: translateY(-8px) rotate(-5deg) scale(1.05); }
    100% { transform: translateY(0) rotate(0) scale(1); }
}

/* Навігація */
.navigation-buttons {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin: 30px auto;
    max-width: 1000px;
}
.nav-button {
    display: flex;
    align-items: center;
    background: linear-gradient(135deg, #2b3a3b, #3e5c5e);
    color: #e0e0e0;
    padding: 10px 20px;
    border-radius: 10px;
    font-size: 16px;
    text-decoration: none;
    transition: all 0.3s ease;
    border: 1px solid rgba(255,77,77,0.3);
    font-weight: bold;
}
.nav-button:hover {
    background: linear-gradient(135deg, #c1121f, #e63946);
    color: #ffffff;
    transform: scale(1.03);
    box-shadow: 0 4px 12px rgba(193,18,31,0.3);
}
.nav-button svg { margin-right: 8px; fill: currentColor; }

#completionModal .modal-content {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 40px;
}
#completionModal .completion-message {
    text-align: center;
    max-width: 500px;
}

.glow-title {
    text-align: center;
    font-size: 2em;
    color: #e8e8e8;
    font-family: 'Verdana', sans-serif;
    text-shadow: 0 0 10px #e8e8e8, 0 0 20px #00d4ff, 0 0 30px #00d4ff;
    animation: glow 2s ease-in-out infinite alternate;
}

/* Summary */
.summary-container {
    margin-top: 25px;
    padding: 0 10px;
}
details {
    margin: 18px 0;
    border-radius: 16px;
    overflow: hidden;
    background: transparent;
    border: 1px solid rgba(255, 77, 77, 0.2);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
    transition: all 0.3s ease;
}
details[open] {
    box-shadow: 0 12px 35px rgba(255, 77, 77, 0.25);
    transform: translateY(-4px);
    border-color: #ff4d4d;
}
summary {
    font-weight: 700;
    padding: 16px 24px;
    background: linear-gradient(135deg, #1c2526 0%, #2e3a3b 100%);
    color: #ff9999;
    font-family: 'Merriweather', Georgia, serif;
    font-size: 1.2rem;
    letter-spacing: 0.7px;
    cursor: pointer;
    list-style: none;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-radius: 16px;
    transition: all 0.3s ease;
    box-shadow: 0 4px 14px rgba(255, 77, 77, 0.2);
    user-select: none;
    border-bottom: 1px solid rgba(255, 77, 77, 0.3);
}
summary::-webkit-details-marker,
summary::marker { display: none; }
summary::after {
    content: "expand_more";
    font-family: 'Material Icons', sans-serif;
    font-size: 1.6rem;
    color: #ff4d4d;
    transition: transform 0.3s ease, color 0.3s ease;
}
details[open] summary::after {
    content: "expand_less";
    color: #ff9999;
}
summary:hover {
    background: linear-gradient(135deg, #253435, #334c4e);
    color: #ffffff;
    box-shadow: 0 6px 20px rgba(255, 77, 77, 0.35);
    transform: translateY(-1px);
}
summary:focus-visible {
    outline: 3px solid #ff4d4d;
    outline-offset: 2px;
}
details > div {
    padding: 22px 26px;
    background: linear-gradient(180deg, rgba(28, 37, 38, 0.95) 0%, rgba(46, 58, 59, 0.95) 100%);
    color: #e0e0e0;
    font-size: 1.05rem;
    line-height: 1.8;
    border-top: 1px dashed rgba(255, 77, 77, 0.3);
    animation: slideDown 0.45s ease-out;
    border-bottom-left-radius: 16px;
    border-bottom-right-radius: 16px;
    box-shadow: inset 0 2px 12px rgba(0, 0, 0, 0.3);
}
@keyframes slideDown {
    from { opacity: 0; transform: translateY(-15px); }
    to { opacity: 1; transform: translateY(0); }
}
details .math-notation-centered {
    background: rgba(255, 153, 153, 0.1);
    color: #ffff99 !important;
    padding: 16px;
    border-radius: 12px;
    margin: 18px 0;
    border-left: 5px solid #ff4d4d;
    box-shadow: 0 3px 10px rgba(255, 77, 77, 0.15);
    text-align: center;
    font-size: 1.1rem;
    font-style: italic;
}
details .example {
    background: rgba(255, 77, 77, 0.15);
    color: #ff9999;
    padding: 16px 20px;
    border-radius: 12px;
    border-left: 5px solid #ff4d4d;
    margin: 20px 0;
    font-weight: 600;
    font-style: italic;
    box-shadow: 0 3px 10px rgba(255, 77, 77, 0.1);
}
details .solution {
    background: rgba(255, 77, 77, 0.2);
    color: #ff4d4d;
    padding: 16px 20px;
    border-radius: 12px;
    margin-top: 20px;
    font-weight: bold;
    border: 2px solid #ff4d4d;
    text-align: center;
    box-shadow: 0 4px 12px rgba(255, 77, 77, 0.2);
}



/* Стилі для питань тренажера */
#trainerModal #questionText {
    color: #e0e0e0; /* білий колір для тексту */
    font-family: 'Roboto Condensed', sans-serif;
    font-size: clamp(18px, 3vw, 20px);
    line-height: 1.6;
    text-align: center;
    margin: 20px 0;
}

/* Стилі для математичних формул в тренажері */
#trainerModal #questionText mjx-container {
    color: #ffff99 !important;
    font-size: 1.1em !important;
    margin: 10px 0 !important;
}


    

/* Адаптивність */
@media (max-width: 768px) {
    .title-box { margin-top: 40px; padding: 15px 20px; }
    .title-box h1 { font-size: 24px; }
    .section-container { flex-direction: column; align-items: center; gap: 20px; }
    .section { width: 80%; height: 180px; }
    .modal { top: 2%; left: 2%; width: 96%; height: 96%; }
    .options-container { flex-direction: column; }
    .option { max-width: 100%; }
    .theory-content h2 { font-size: 22px; }
    .math-notation-centered { font-size: clamp(15px, 2.8vw, 16px); }
    mjx-container { font-size: 16px !important; }
    .video-card { width: 260px; height: 160px; }
    .options-container { flex-direction: column; align-items: center; }
    .option { max-width: 100%; width: 100%; }
    #trainerModal mjx-container { font-size: 1.3em !important; }
    #trainerModal #questionText mjx-container { font-size: 1.2em !important; }
    #trainerModal .option mjx-container { font-size: 1.2em !important; }
    
    /* Горизонтальна прокрутка для формул в details */
    details .math-notation-centered {
        display: block !important;
        overflow-x: auto !important;
        overflow-y: hidden !important;
        -webkit-overflow-scrolling: touch !important;
        white-space: nowrap !important;
        padding: 12px 0 !important;
        margin: 15px 0 !important;
        text-align: center !important;
        max-height: none !important;
        height: auto !important;
    }
    details .math-notation-centered mjx-container {
        display: inline-block !important;
        white-space: nowrap !important;
        font-size: 18px !important;
        line-height: 1.4 !important;
    }
    details .math-notation-centered::-webkit-scrollbar { display: none; }
    details .math-notation-centered {
        -ms-overflow-style: none;
        scrollbar-width: none;
    }
}

@media (max-width: 480px) {
    .title-box h1 { font-size: 20px; }
    .section { width: 90%; height: 150px; }
    .section h2 { font-size: 18px; }
    .theory-content h2 { font-size: 18px; }
    .math-notation-centered { font-size: clamp(11px, 2vw, 12px); }
    summary { font-size: 0.9rem; }
    mjx-container { font-size: 14px !important; }
    .video-card { width: 260px; height: 160px; }
    #trainerModal mjx-container { font-size: 1.2em !important; }
    #trainerModal #questionText mjx-container { font-size: 1.1em !important; }
    #trainerModal .option mjx-container { font-size: 1.1em !important; }
    .question-circle h3 { font-size: clamp(12px, 2vw, 14px); }
}
    #trainerModal #questionText mjx-container {
    
    font-size: 0.9em !important;
    
}
                        .feedback {
    
    font-size: clamp(16px, 2.4vw, 17px);
    
}

/* Адаптивність для мобільних */
@media (max-width: 768px) {
    .question-card {
        min-height: 120px;
        margin: 15px auto;
    }
    
    .card-inner {
        min-height: 150px;
    }
    
    .card-front, .card-back {
        min-height: 150px;
        padding: 15px;
    }
    
    .card-back {
        padding: 18px;
    }
    
    .card-front span, .card-back span {
        font-size: 16px;
        line-height: 1.4;
    }
}

@media (max-width: 480px) {
    .question-card {
        min-height: 100px;
        margin: 12px auto;
    }
    
    .card-inner {
        min-height: 130px;
    }
    
    .card-front, .card-back {
        min-height: 130px;
        padding: 12px;
    }
    
    .card-back {
        padding: 15px;
        text-align: left;
    }
    
    .card-front span, .card-back span {
        font-size: 15px;
        line-height: 1.3;
    }
}

    </style>
</head>
<body>
    <div class="title-box">
        <h1>45. Обчислення кута між прямими</h1>
    </div>

    <div class="section-container">
        <div class="section" id="openTheoryBtn">
            <img src="https://img.icons8.com/fluency/96/book-shelf.png" alt="Книга">
            <h2>Теоретичні відомості</h2>
        </div>
        <div class="section" id="openVideoBtn">
            <img src="https://img.icons8.com/fluency/96/video.png" alt="Відео">
            <h2>Відеоматеріали</h2>
        </div>
        <div class="section" id="openQuestionsBtn">
            <img src="https://img.icons8.com/fluency/96/flipboard.png" alt="Картки">
            <h2>Питання і відповіді</h2>
        </div>
        <div class="section" id="openTrainerBtn">
            <img src="https://img.icons8.com/fluency/96/flash-on.png" alt="Тренажер">
            <h2>Тренажер</h2>
        </div>
    </div>

    <div class="navigation-buttons">
        <a class="nav-button" href='tema9.html'>
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24">
                <path d="M15 18l-6-6 6-6"/>
            </svg>
            До теми 9
        </a>
        <a class="nav-button" href='index.html'>
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24">
                <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
            </svg>
            На головну
        </a>
    </div>

   <!-- Теорія -->
<div id="theoryModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <button class="close-btn" id="closeTheoryBtn">× Закрити</button>
        </div>

        <div class="theory-content">
            <h2>Обчислення кута між прямими</h2>

            <p>
                Кут між двома прямими допомагає визначити їх взаємне розташування на площині: чи перетинаються вони, чи є паралельними. 
                Нехай дві прямі \( l_1 \) і \( l_2 \) перетинаються в точці \( S \), утворюючи чотири кути: \( \angle 1 \), \( \angle 2 \), \( \angle 3 \) і \( \angle 4 \) (рис. 9.26). 
<img src="/static/figure9.26.jpg" alt="Кути" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
                   За властивістю суміжних кутів: \( \angle 1 + \angle 2 = 180^\circ \) та \( \angle 1 + \angle 4 = 180^\circ \). 
                З цього випливає, що \( \angle 2 = \angle 4 \). Аналогічно \( \angle 1 = \angle 3 \), оскільки це вертикальні кути. 
                Таким чином, при перетині двох прямих утворюються дві пари вертикальних кутів: \( \angle 1 \) і \( \angle 3 \), а також \( \angle 2 \) і \( \angle 4 \).
            </p>

            <p>
                Під <strong>кутом між двома прямими</strong> зазвичай розуміють <strong>найменший із суміжних кутів</strong>, тобто гострий кут (менший або дорівнює \( 90^\circ \)). Саме цей кут використовується в обчисленнях.
            </p>

            <p>
                Для обчислення кута між прямими можна використовувати різні підходи залежно від того, як ці прямі задані:
            </p>
            <ol>
                <li>Якщо прямі \( l_1 \) і \( l_2 \) задані <strong>загальними рівняннями</strong>, то кут між ними зручніше обчислювати як кут між їх <strong>нормальними векторами</strong>, використовуючи косинус через скалярний добуток.</li>
                <li>Якщо прямі \( l_1 \) і \( l_2 \) задані <strong>рівняннями з кутовими коефіцієнтами</strong>, то кут між ними зручніше обчислювати через <strong>тангенс їхніх кутів нахилу</strong>.</li>
            </ol>

            <p><strong>Розглянемо обидва випадки:</strong></p>

         <!-- Вкладка 1: Загальні рівняння -->
<details>
    <summary>Кут між прямими заданими загальними рівняннями</summary>
    <div>
        <p>
            Нехай на площині задано прямокутну декартову систему координат, і загальні рівняння двох різних прямих \( l_1 \) і \( l_2 \), які мають вигляд:
        </p>

      <p class="math-notation-centered">
\[
\begin{aligned}
l_1: A_1 x + B_1 y + C_1 = 0, \\
l_2: A_2 x + B_2 y + C_2 = 0.
\end{aligned}
\]
</p>

        <p>
            З рівняння прямої \( l_1 \) можна визначити координати нормального вектора \( \vec{n_1} = (A_1, B_1) \), а з рівняння прямої \( l_2 \) — \( \vec{n_2} = (A_2, B_2) \).  
            Кут між прямими \( l_1 \) і \( l_2 \) позначимо через \( \varphi \), тобто \( \angle(l_1, l_2) = \varphi \).  
            Кут між нормальними векторами \( \vec{n_1} \) і \( \vec{n_2} \) позначимо через \( \psi \), тобто \( \angle(\vec{n_1}, \vec{n_2}) = \psi \).
        </p>

        <p><strong>Зв’язок між кутами:</strong></p>
        <ul>
            <li>Якщо \( \psi \leq 90^\circ \) (рис. 9.27), то \( \varphi = \psi \).</li>
            <li>Якщо \( \psi > 90^\circ \) (рис. 9.28), то \( \varphi = 180^\circ - \psi \).</li>
        </ul>
        <img src="/static/figure9.27.jpg" alt="Кути прямих загальним" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
   
        <p>
            У будь-якому випадку виконується рівність:
            <p class="math-notation-centered">
                \[ \cos \varphi = |\cos \psi| \]
            </p>
            Це пояснюється тим, що ми завжди обираємо <strong>найменший (гострий) кут</strong> між прямими, тобто \( \varphi \leq 90^\circ \).
        </p>

        <p>
            Кут \( \psi \) між нормальними векторами можна знайти через їхній <strong>скалярний добуток</strong>:
            <p class="math-notation-centered">
                \[ \cos \psi = \frac{\vec{n_1} \cdot \vec{n_2}}{|\vec{n_1}| \cdot |\vec{n_2}|} \]
            </p>
            Оскільки \( \cos \varphi = |\cos \psi| \), то:
            <p class="math-notation-centered">
                \[ \cos \varphi = \frac{|\vec{n_1} \cdot \vec{n_2}|}{|\vec{n_1}| \cdot |\vec{n_2}|} \tag{9.13} \]
            </p>
        </p>

        <p>
            Підставляючи координати нормальних векторів, отримаємо:
            <p class="math-notation-centered">
                \[ \cos \varphi = \frac{|A_1 A_2 + B_1 B_2|}{\sqrt{A_1^2 + B_1^2} \cdot \sqrt{A_2^2 + B_2^2}} \tag{9.14} \]
            </p>
        </p>

        <!-- Приклад -->
        <div class="example">
            <strong>Приклад 9.15.</strong> Дано дві прямі: \( 3x + 4y - 25 = 0 \) і \( 4x + 3y - 25 = 0 \). Обчислити кут між ними.
        </div>

        <p>
            Кут між даними прямими визначимо як кут між їхніми нормальними векторами.  
            Запишемо координати нормальних векторів:
            <p class="math-notation-centered">
                \[ \vec{n_1} = (3, 4), \quad \vec{n_2} = (4, 3). \]
            </p>
        </p>

        <p>Використаємо формулу (9.13):</p>

        <p>Обчислимо скалярний добуток:</p>
        <p class="math-notation-centered">
            \[ \vec{n_1} \cdot \vec{n_2} = 3 \cdot 4 + 4 \cdot 3 = 12 + 12 = 24. \]
        </p>

        <p>Обчислимо довжини векторів:</p>
       <p class="math-notation-centered">
\[
\begin{aligned}
|\vec{n_1}| &= \sqrt{3^2 + 4^2} = \sqrt{25} = 5, \\
|\vec{n_2}| &= \sqrt{4^2 + 3^2} = \sqrt{25} = 5.
\end{aligned}
\]
</p>


        <p>Підставимо значення у формулу:</p>
       <p class="math-notation-centered">
\[
\begin{aligned}
\cos \varphi &= \frac{|24|}{5 \cdot 5} = \frac{24}{25}, \\
\varphi &= \arccos \frac{24}{25} \approx 16^\circ.
\end{aligned}
\]
</p>

        <p class="solution">
            <strong>Відповідь:</strong> \( \varphi = \arccos \frac{24}{25} \approx 16^\circ \).
        </p>
    </div>
</details>

            <!-- Вкладка 2: Кутові коефіцієнти -->
<details>
    <summary>Кут між прямими, заданими рівняннями з кутовими коефіцієнтами</summary>
    <div>
        <p>
            Нехай на площині задана прямокутна декартова система координат, і дві різні прямі \( l_1 \) і \( l_2 \) задані рівняннями з кутовими коефіцієнтами \( k_1 \) і \( k_2 \):
        </p>

      <p class="math-notation-centered">
\[
\begin{aligned}
l_1: &\; y = k_1 x + b_1, \\
l_2: &\; y = k_2 x + b_2.
\end{aligned}
\]
</p>


        <p>
            Припускаємо, що жодна з цих прямих не є паралельною осі \( Oy \), оскільки такі прямі не мають кутового коефіцієнта.
        </p>

        <p>
            Кут між прямими \( l_1 \) і \( l_2 \) позначимо через \( \varphi \). Геометрично цей кут можна уявити як кут, на який потрібно повернути пряму \( l_1 \) проти годинникової стрілки, щоб вона збіглася з прямою \( l_2 \) (рис. 9.29).  

            У аналітичній геометрії зазвичай обирають <strong>найменший (гострий) кут</strong> між прямими, тобто \( 0^\circ \leq \varphi \leq 90^\circ \).
        </p>

        <p>
            Позначимо:  
            \( \alpha_1 \) — кут нахилу прямої \( l_1 \) до осі \( Ox \),  
            \( \alpha_2 \) — кут нахилу прямої \( l_2 \) до осі \( Ox \), і \( \alpha_2 > \alpha_1 \).
        </p>
<img src="/static/figure9.29.jpg" alt="Кути прямих з кутовим" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
   
        <p>
            Кут нахилу прямої визначається через її кутовий коефіцієнт:
            <p class="math-notation-centered">
\[
\begin{aligned}
\mathrm{tg}\,\alpha &= k \quad \Rightarrow \quad \mathrm{tg}\,\alpha_1 = k_1, \\
\mathrm{tg}\,\alpha_2 &= k_2.
\end{aligned}
\]
</p>

        </p>

        <p>
            Кут \( \varphi \) між прямими пов’язаний із кутами нахилу так:
            <p class="math-notation-centered">
                \[ \varphi = \alpha_2 - \alpha_1. \]
            </p>
        </p>

        <p>
            Застосуємо формулу тангенса різниці кутів:
            <p class="math-notation-centered">
                \[ \mathrm{tg}\,\varphi = \frac{\mathrm{tg}\,\alpha_2 - \mathrm{tg}\,\alpha_1}{1 + \mathrm{tg}\,\alpha_1 \cdot \mathrm{tg}\,\alpha_2}. \]
            </p>
        </p>

        <p>
            Підставляючи \( \mathrm{tg}\,\alpha_1 = k_1 \), \( \mathrm{tg}\,\alpha_2 = k_2 \), отримаємо:
            <p class="math-notation-centered">
                \[ \mathrm{tg}\,\varphi = \frac{k_2 - k_1}{1 + k_1 k_2}. \]
            </p>
        </p>

        <p>
            Оскільки ми обираємо гострий кут між прямими, беремо абсолютну величину:
            <p class="math-notation-centered">
                \[ \mathrm{tg}\,\varphi = \left| \frac{k_2 - k_1}{1 + k_1 k_2} \right| \tag{9.15} \]
            </p>
        </p>

        <p>
            Ця формула дозволяє обчислити тангенс кута, а сам кут \( \varphi \) знайти через обернений тангенс:
            <p class="math-notation-centered">
                \[ \varphi = \mathrm{arctg} \left| \frac{k_2 - k_1}{1 + k_1 k_2} \right|. \]
            </p>
        </p>

        <h4>Особливі випадки:</h4>
        <ul>
            <li>Якщо \( k_1 = k_2 \), то \( \varphi = 0^\circ \) (прямі <strong>паралельні</strong>).</li>
            <li>Якщо \( k_1 k_2 = -1 \), то знаменник \( 1 + k_1 k_2 = 0 \), тому \( \mathrm{tg}\,\varphi \to \infty \), що відповідає \( \varphi = 90^\circ \) (прямі <strong>перпендикулярні</strong>).</li>
        </ul>

        <div class="example">
            <strong>Приклад 9.16.</strong> Дано дві прямі: \( y = -3x + 7 \) і \( y = -\frac{1}{2}x - \frac{9}{2} \). Знайти кут між ними.
        </div>

        <p>
            Кутовий коефіцієнт першої прямої: \( k_1 = -3 \),  
            другої: \( k_2 = -\frac{1}{2} \).
        </p>

        <p>Використаємо формулу (9.15):</p>
        <p class="math-notation-centered">
            \[ \mathrm{tg}\,\varphi = \left| \frac{k_2 - k_1}{1 + k_1 k_2} \right| \]
        </p>

        <p>Підставимо значення:</p>
        <p class="math-notation-centered">
            \[ \mathrm{tg}\,\varphi = \left| \frac{-\frac{1}{2} - (-3)}{1 + (-3) \cdot (-\frac{1}{2})} \right| = \left| \frac{-\frac{1}{2} + 3}{1 + \frac{3}{2}} \right| = \left| \frac{\frac{5}{2}}{\frac{5}{2}} \right| = 1 \]
        </p>

        <p>Отже:</p>
        <p class="math-notation-centered">
            \[ \varphi = \mathrm{arctg}\,1 = 45^\circ \]
        </p>

        <p class="solution">
            <strong>Відповідь:</strong> \( \varphi = 45^\circ \).
        </p>
    </div>
</details>

            
        </div>
    </div>
</div>
    
   <div id="videoModal" class="modal">
        <div class="modal-header">
            <button class="close-btn" id="closeVideoBtn">× Закрити</button>
        </div>
        <div class="modal-content">
            <h2 class="glow-title">Оберіть відео</h2>
            <div class="video-card-container">
                <div class="video-card" data-video="1">
                    <img src="https://img.icons8.com/?size=100&id=o1CR3NjO7Pv8&format=png&color=000000" alt="Відеокамера">
                    <h3>Кут між прямими, що задані через кутовий коефіцієнт</h3>
                </div>
                <div class="video-card" data-video="2">
                    <img src="https://img.icons8.com/?size=100&id=o1CR3NjO7Pv8&format=png&color=000000" alt="Відеокамера">
                    <h3>Умова паралельності, перпендикулярності Кут між прямими, що задані загальними рівняннями</h3>
                </div>
                            </div>
        </div>
    </div>

    <div id="videoPlayerModal1" class="modal">
        <div class="modal-header">
            <button class="close-btn" id="closeVideoPlayerBtn1">× Закрити</button>
        </div>
        <div class="modal-content">
            <div class="video-player-container">
                <iframe id="youtubePlayer1" width="100%" src="https://www.youtube.com/embed/fYRlILvk6jU" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            </div>
        </div>
    </div>

    <div id="videoPlayerModal2" class="modal">
        <div class="modal-header">
            <button class="close-btn" id="closeVideoPlayerBtn2">× Закрити</button>
        </div>
        <div class="modal-content">
            <div class="video-player-container">
                <iframe id="youtubePlayer2" width="100%" src="https://www.youtube.com/embed/vpKDJhFzGz0" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            </div>
        </div>
    </div>


   <!-- Питання і відповіді -->
<div id="questionsModal" class="modal">
    <div class="modal-header">
        <button class="close-btn" id="closeQuestionsBtn">× Закрити</button>
    </div>
    <div class="modal-content">

        <!-- 1 -->
        <div class="question-card" onclick="this.classList.toggle('flipped')">
            <div class="card-inner">
                <div class="card-front">
                    <span>1. Який кут вважається кутом між двома прямими?</span>
                </div>
                <div class="card-back">
                    <span>Найменший із суміжних кутів, тобто гострий \( (≤ 90°) \).</span>
                </div>
            </div>
        </div>

               <!-- 2 -->
        <div class="question-card" onclick="this.classList.toggle('flipped')">
            <div class="card-inner">
                <div class="card-front">
                    <span>2. Як можна обчислити кут між двома прямими, заданими загальними рівняннями?</span>
                </div>
                <div class="card-back">
                    <span>Через косинус кута між їх нормальними векторами.</span>
                </div>
            </div>
        </div>

        <!-- 3 -->
        <div class="question-card" onclick="this.classList.toggle('flipped')">
            <div class="card-inner">
                <div class="card-front">
                    <span>3. Які координати мають нормальні вектори для прямих \( l_1 \) і \( l_2 \), що задані загальними рівняннями?</span>
                </div>
                <div class="card-back">
                    <span>\( \vec{n_1}(A_1; B_1), \quad \vec{n_2}(A_2; B_2) \).</span>
                </div>
            </div>
        </div>

        <!-- 4 -->
        <div class="question-card" onclick="this.classList.toggle('flipped')">
            <div class="card-inner">
                <div class="card-front">
                    <span>4. Яка формула для косинуса кута між двома прямими?</span>
                </div>
                <div class="card-back">
                    <span>
                        \[
                        \cos \varphi = 
                        \frac{|A_1A_2 + B_1B_2|}
                        {\sqrt{A_1^2 + B_1^2} \cdot \sqrt{A_2^2 + B_2^2}}
                        \]
                    </span>
                </div>
            </div>
        </div>

       <!-- 5 -->
<div class="question-card" onclick="this.classList.toggle('flipped')">
    <div class="card-inner">
        <div class="card-front">
            <span>5. Як зручно обчислювати кут між прямими, якщо вони задані рівняннями з кутовими коефіцієнтами?</span>
        </div>
        <div class="card-back">
            <span>Через тангенси їхніх кутів нахилу</span>
          
        </div>
    </div>
</div>


        <!-- 6 -->
        <div class="question-card" onclick="this.classList.toggle('flipped')">
            <div class="card-inner">
                <div class="card-front">
                    <span>6. Який зв’язок між кутом нахилу прямої \( \varphi \) та її кутовим коефіцієнтом \( k \)?</span>
                </div>
                <div class="card-back">
                    <span>\( \mathrm{tg}\,\varphi = k \).</span>
                </div>
            </div>
        </div>

        <!-- 7 -->
        <div class="question-card" onclick="this.classList.toggle('flipped')">
            <div class="card-inner">
                <div class="card-front">
                    <span>7. Яка формула для тангенса кута між двома прямими через їхні коефіцієнти?</span>
                </div>
                <div class="card-back">
                    <span>
                       \[ \mathrm{tg}\,\varphi = \left| \frac{k_2 - k_1}{1 + k_1 k_2} \right| \]
                    </span>
                </div>
            </div>
        </div>

        <!-- 8 -->
        <div class="question-card" onclick="this.classList.toggle('flipped')">
            <div class="card-inner">
                <div class="card-front">
                    <span>8. Як знайти сам кут між прямими, знаючи \( k_1 \) і \( k_2 \)?</span>
                </div>
                <div class="card-back">
                    <span>
                        \[
                        \varphi = \mathrm{arctg}

                        \left| \frac{k_2 - k_1}{1 + k_1 k_2} \right|
                        \]
                    </span>
                </div>
            </div>
        </div>

        <!-- 11 -->
        <div class="question-card" onclick="this.classList.toggle('flipped')">
            <div class="card-inner">
                <div class="card-front">
                    <span>11. Що означає, якщо \( k_1 = k_2 \)?</span>
                </div>
                <div class="card-back">
                    <span>Прямі паралельні, кут між ними \( \varphi = 0^\circ \).</span>
                </div>
            </div>
        </div>

        <!-- 9 -->
        <div class="question-card" onclick="this.classList.toggle('flipped')">
            <div class="card-inner">
                <div class="card-front">
                    <span>9. Що означає, якщо \( k_1 k_2 = -1 \)?</span>
                </div>
                <div class="card-back">
                    <span>Прямі перпендикулярні, \( \varphi = 90^\circ \).</span>
                </div>
            </div>
        </div>

        <!-- 10 -->
        <div class="question-card" onclick="this.classList.toggle('flipped')">
            <div class="card-inner">
                <div class="card-front">
                    <span>10. Чому у формулах для обчислення кута між прямими використовують модуль?</span>
                </div>
                <div class="card-back">
                    <span>Щоб отримати найменший (гострий) кут, адже \( \varphi \le 90^\circ \).</span>
                </div>
            </div>
        </div>

    </div>
</div>


      <!-- Тренажер (без блоку завершення) -->
<div id="trainerModal" class="modal">
    <div class="modal-header">
        <button class="close-btn" id="closeTrainerBtn">× Закрити</button>
    </div>
    <div class="modal-content">
        <div class="trainer-container" id="trainerContent">
            <div class="question-circle">
                <h3 id="questionNumber">Питання 1</h3>
            </div>
            <p id="questionText" class="math-notation-centered"></p>
            <div class="options-container" id="optionsContainer"></div>
            <button id="submitAnswer" disabled>Підтвердити</button>
            <div id="feedback" class="feedback"></div>
        </div>
    </div>
</div>

<!-- НОВЕ: Окреме вікно завершення -->
<div id="completionModal" class="modal">
    <div class="modal-header">
        <button class="close-btn" id="closeCompletionBtn">× Закрити</button>
    </div>
    <div class="modal-content">
        <div class="completion-message">
    <div class="completion-emoji"></div>
    <h2>МІСІЯ ВИКОНАНА!</h2>
    <p>Солдате, ти — гордість України!</p>
    <p><strong>СЛАВА УКРАЇНІ!</strong></p>
    <button id="resetTrainerBtn">Повернутися на полігон!</button>
</div>
    </div>
</div>
    <div id="modalOverlay"></div>

    <script>
document.addEventListener('DOMContentLoaded', function () {
    document.body.classList.add('loaded');

    // === Всі елементи ===
    const els = {
        openTheoryBtn: document.getElementById('openTheoryBtn'),
        openVideoBtn: document.getElementById('openVideoBtn'),
        openQuestionsBtn: document.getElementById('openQuestionsBtn'),
        openTrainerBtn: document.getElementById('openTrainerBtn'),

        theoryModal: document.getElementById('theoryModal'),
        videoModal: document.getElementById('videoModal'),  // головне: список відео
        questionsModal: document.getElementById('questionsModal'),
        trainerModal: document.getElementById('trainerModal'),
        completionModal: document.getElementById('completionModal'),

        videoPlayer1: document.getElementById('videoPlayerModal1'),  // плеєр 1
        videoPlayer2: document.getElementById('videoPlayerModal2'),  // плеєр 2

        closeTheoryBtn: document.getElementById('closeTheoryBtn'),
        closeVideoBtn: document.getElementById('closeVideoBtn'),
        closeQuestionsBtn: document.getElementById('closeQuestionsBtn'),
        closeTrainerBtn: document.getElementById('closeTrainerBtn'),
        closeCompletionBtn: document.getElementById('closeCompletionBtn'),
        closeVideoPlayer1: document.getElementById('closeVideoPlayerBtn1'),
        closeVideoPlayer2: document.getElementById('closeVideoPlayerBtn2'),

        modalOverlay: document.getElementById('modalOverlay'),

        questionNumber: document.getElementById('questionNumber'),
        questionText: document.getElementById('questionText'),
        optionsContainer: document.getElementById('optionsContainer'),
        submitAnswer: document.getElementById('submitAnswer'),
        feedback: document.getElementById('feedback'),
        resetTrainerBtn: document.getElementById('resetTrainerBtn')
    };

    // === Універсальна функція toggleModal ===
    function toggleModal(modal, show) {
        if (!modal) return;
        modal.style.display = show ? 'flex' : 'none';
        els.modalOverlay.style.display = show ? 'block' : 'none';
        document.body.style.overflow = show ? 'hidden' : 'auto';

        if (show && window.MathJax?.typesetPromise) {
            MathJax.typesetPromise([modal]).catch(() => {});
        }
    }

    // === Зупинка YouTube відео ===
    function stopVideo(modal) {
        const iframe = modal.querySelector('iframe');
        if (iframe && iframe.src) {
            const src = iframe.src;
            iframe.src = '';
            iframe.src = src;
        }
    }

    // === Відкриття основних модалок ===
    els.openTheoryBtn.addEventListener('click', () => toggleModal(els.theoryModal, true));
    els.openVideoBtn.addEventListener('click', () => toggleModal(els.videoModal, true));
    els.openQuestionsBtn.addEventListener('click', () => toggleModal(els.questionsModal, true));
    els.openTrainerBtn.addEventListener('click', () => {
        toggleModal(els.trainerModal, true);
        initTrainer();
    });

    // === Закриття всіх модалок ===
    [
        els.closeTheoryBtn,
        els.closeVideoBtn,
        els.closeQuestionsBtn,
        els.closeTrainerBtn,
        els.closeCompletionBtn,
        els.closeVideoPlayer1,
        els.closeVideoPlayer2
    ].forEach(btn => {
        if (btn) {
            btn.addEventListener('click', () => {
                const modal = btn.closest('.modal');
                if (modal.id === 'videoPlayerModal1' || modal.id === 'videoPlayerModal2') {
                    stopVideo(modal);
                    toggleModal(modal, false);
                    toggleModal(els.videoModal, true); // повернення до списку
                } else {
                    toggleModal(modal, false);
                    if (modal === els.completionModal) {
                        toggleModal(els.trainerModal, false);
                    }
                }
            });
        }
    });

    // Закриття по кліку на overlay
    els.modalOverlay.addEventListener('click', () => {
        document.querySelectorAll('.modal').forEach(m => {
            if (m.style.display === 'flex') {
                if (m.id === 'videoPlayerModal1' || m.id === 'videoPlayerModal2') {
                    stopVideo(m);
                }
                toggleModal(m, false);
            }
        });
    });

    // Закриття по Esc
    document.addEventListener('keydown', e => {
        if (e.key === 'Escape') {
            document.querySelectorAll('.modal').forEach(m => {
                if (m.style.display === 'flex') {
                    if (m.id === 'videoPlayerModal1' || m.id === 'videoPlayerModal2') {
                        stopVideo(m);
                    }
                    toggleModal(m, false);
                }
            });
        }
    });

    // === ВІДЕО: Картки → Відкриття плеєра ===
    const videoCards = document.querySelectorAll('.video-card');
    const videoPlayerModals = {
        1: els.videoPlayer1,
        2: els.videoPlayer2
    };

    videoCards.forEach(card => {
        card.addEventListener('click', () => {
            const videoId = card.getAttribute('data-video');
            const playerModal = videoPlayerModals[videoId];
            if (playerModal) {
                toggleModal(els.videoModal, false);
                toggleModal(playerModal, true);
            }
        });
    });

// === ТРЕНАЖЕР: Питання 1 (cos φ) → Питання 2 (кут між прямими) ===
let selected = null;
let correct = null;
let currentQuestionType = 1; // 1 = cos φ, 2 = кут, 3 = tan φ

// === НСД (gcd) ===
function gcd(a, b) {
    a = Math.abs(a);
    b = Math.abs(b);
    while (b) {
        const t = b;
        b = a % b;
        a = t;
    }
    return a;
}

    // === Точний дріб: num/den ===
function makeFraction(num, den) {
    const g = gcd(num, den);
    return {
        num: num / g,
        den: den / g
    };
}

    // === Формат дробу як \frac або число ===
function formatFraction(fracObj) {
    let { num, den } = fracObj;

    // Захист від ділення на 0
    if (den === 0) return '∞';

    // Якщо чисельник нуль → 0
    if (num === 0) return '0';

    // Скорочуємо дріб
    const g = gcd(num, den);
    num = num / g;
    den = den / g;

    // Якщо знаменник = 1 → повертаємо ціле число
    if (den === 1) return `${num}`;

    // Якщо обидва від’ємні → робимо додатні
    if (num < 0 && den < 0) {
        num = Math.abs(num);
        den = Math.abs(den);
    }

    // Якщо тільки знаменник від’ємний → переносимо знак у чисельник
    if (den < 0) {
        num = -num;
        den = Math.abs(den);
    }

    // Повертаємо скорочений дріб
    return `\\frac{${num}}{${den}}`;
}




// === Генерація k: цілі або дроби (наприклад: 2, -3, 1/2, -3/4) ===
function randSlope() {
    const numerators = [-5, -4, -3, -2, -1, 1, 2, 3, 4, 5];
    const denominators = [1, 2, 3, 4, 5]; // тільки прості дроби

    const num = numerators[Math.floor(Math.random() * numerators.length)];
    const den = denominators[Math.floor(Math.random() * denominators.length)];

    return { num, den }; // повертаємо як об'єкт: {num: 1, den: 2}
}
    
    function randB() {
    return Math.floor(Math.random() * 21) - 10; // від -10 до 10
}
    
   // === ТОЧНЕ перетворення в спрощений дріб або ціле ===
function toFraction(value, maxDenom = 50) {
    if (Math.abs(value) < 1e-10) return '0';

    // Якщо число ціле (наприклад, 2.0) → просто повертаємо його
    if (Math.abs(value - Math.round(value)) < 1e-10) {
        return `${Math.round(value)}`;
    }

    let bestN = 0;
    let bestD = 1;
    let bestError = Infinity;

    for (let d = 1; d <= maxDenom; d++) {
        const n = Math.round(value * d);
        const error = Math.abs(n / d - value);
        if (error < bestError) {
            bestError = error;
            bestN = n;
            bestD = d;
        }
    }

    // Спрощуємо
    const divisor = gcd(bestN, bestD);
    const simpleN = bestN / divisor;
    const simpleD = bestD / divisor;

    // Якщо знаменник 1 → ціле число
    if (simpleD === 1) {
        return `${simpleN}`;
    } else {
        return `\\frac{${simpleN}}{${simpleD}}`;
    }
}

// === Формат k: 2, -3, 1/2, -3/4 (спрощений) ===
function formatSlope(kObj) {
    let { num, den } = kObj;

    // Спрощуємо дріб
    const divisor = gcd(num, den);
    num = num / divisor;
    den = den / divisor;

    if (den === 1) {
        return num >= 0 ? `${num}` : `-${Math.abs(num)}`;
    }
    if (num === 0) return '0';

    const sign = num < 0 ? '-' : '';
    return `${sign}\\frac{${Math.abs(num)}}{${den}}`;
}

// === Формат y = kx + b ===
function formatSlopeEq(kObj, b) {
    let { num, den } = kObj;

    // Спрощуємо k
    const divisor = gcd(num, den);
    num = num / divisor;
    den = den / divisor;

    let kPart = '';
    if (num === 1 && den === 1) {
        kPart = '';
    } else if (num === -1 && den === 1) {
        kPart = '-';
    } else {
        const sign = num < 0 ? '-' : '';
        const absNum = Math.abs(num);
        kPart = den === 1 ? `${sign}${absNum}` : `${sign}\\frac{${absNum}}{${den}}`;
    }

    let bPart = '';
    if (b !== 0) {
        const sign = b > 0 ? '+' : '-';
        bPart = ` ${sign} ${Math.abs(b)}`;
    }

    return `y = ${kPart}x${bPart}`;
}
    
    function randSlope() {
    const numerators = [-5, -4, -3, -2, -1, 1, 2, 3, 4, 5];
    const denominators = [1, 2, 3, 4, 5];

    let num = numerators[Math.floor(Math.random() * numerators.length)];
    let den = denominators[Math.floor(Math.random() * denominators.length)];

    // Спрощуємо одразу
    const divisor = gcd(num, den);
    num = num / divisor;
    den = den / divisor;

    return { num, den };
}
    
// === Генерація A, B, C ===
function randCoeff() {
    let A, B;
    do {
        A = Math.floor(Math.random() * 11) - 5;
        B = Math.floor(Math.random() * 11) - 5;
    } while (A === 0 && B === 0);
    return { A, B };
}
function randC() {
    return Math.floor(Math.random() * 21) - 10;
}

// === Формат рівняння ===
function formatEq(A, B, C) {
    const parts = [];
    if (A !== 0) {
        if (A === 1) parts.push('x');
        else if (A === -1) parts.push('-x');
        else parts.push(`${A}x`);
    }
    if (B !== 0) {
        let term = B === 1 ? 'y' : B === -1 ? '-y' : `${B}y`;
        if (B > 0 && parts.length > 0) term = '+' + term;
        parts.push(term);
    }
    if (C !== 0) parts.push(C > 0 ? `+${C}` : `${C}`);
    return parts.length === 0 ? '0 = 0' : parts.join(' ') + ' = 0';
}

// === Дріб ===
function toFraction(value, maxDenom = 50) {
    if (Math.abs(value - 1) < 1e-8) return '1';
    if (Math.abs(value) < 1e-8) return '0';
    for (let d = 2; d <= maxDenom; d++) {
        const n = Math.round(value * d);
        if (Math.abs(n / d - value) < 1e-8) return `\\frac{${n}}{${d}}`;
    }
    return null;
}

// === Хибні відповіді для cos φ ===
function generateFakeCos() {
    const types = [
        () => {
            const m = correct.match(/\\frac\{(\d+)\}\{(\d+)\}/);
            if (m) return `\\(\\cos \\varphi = \\frac{${m[2]}}{${m[1]}}\\)`;
            return null;
        },
        () => {
            const n = Math.floor(Math.random() * 20) + 1;
            const d = Math.floor(Math.random() * 30) + 20;
            return `\\(\\cos \\varphi = \\frac{${n}}{${d}}\\)`;
        },
        () => {
            const val = Math.random() * 0.7 + 0.1;
            const frac = toFraction(val);
            return frac ? `\\(\\cos \\varphi = ${frac}\\)` : null;
        }
    ];
    let res;
    do { res = types[Math.floor(Math.random() * types.length)](); }
    while (!res || res === correct);
    return res;
}
    

// === ПИТАННЯ 1: cos φ між прямими ===
function generateQuestion1() {
    const line1 = { ...randCoeff(), C: randC() };
    const line2 = { ...randCoeff(), C: randC() };

    const dot = Math.abs(line1.A * line2.A + line1.B * line2.B);
    const underRoot = (line1.A ** 2 + line1.B ** 2) * (line2.A ** 2 + line2.B ** 2);
    const denom = Math.sqrt(underRoot);
    const cosPhi = dot / denom;

    const frac = toFraction(cosPhi);
    if (!frac) return generateQuestion1();

    correct = `\\(\\cos \\varphi = ${frac}\\)`;

    const options = new Set([correct]);
    while (options.size < 4) {
        const fake = generateFakeCos();
        if (fake) options.add(fake);
    }

    return {
       text: `
    <div class="prompt-text">Обчислити косинус кута між прямими</div>
    <div class="formula">
        \\[
            ${formatEq(line1.A, line1.B, line1.C)} \\quad \\text{і} \\quad ${formatEq(line2.A, line2.B, line2.C)}
        \\]
    </div>
`,
        options: Array.from(options).sort(() => Math.random() - 0.5),
        correct
    };
}

// === ПИТАННЯ 2: Знайти кут між прямими (градуси або arccos) ===
function generateQuestion2() {
    const line1 = { ...randCoeff(), C: randC() };
    const line2 = { ...randCoeff(), C: randC() };

    const dot = Math.abs(line1.A * line2.A + line1.B * line2.B);
    const underRoot = (line1.A ** 2 + line1.B ** 2) * (line2.A ** 2 + line2.B ** 2);
    const denom = Math.sqrt(underRoot);
    const cosPhi = dot / denom;
    const cosRounded = Math.round(cosPhi * 100000) / 100000;

    let correctAnswer;

    if (Math.abs(cosRounded - 1) < 1e-5) {
        correctAnswer = '0^\\circ';
    } else if (Math.abs(cosRounded - 0) < 1e-5) {
        correctAnswer = '90^\\circ';
    } else if (Math.abs(cosRounded - 0.5) < 1e-5) {
        correctAnswer = '60^\\circ';
    } else if (Math.abs(cosRounded - 0.866025) < 1e-5) {
        correctAnswer = '30^\\circ';
    } else if (Math.abs(cosRounded - 0.707107) < 1e-5) {
        correctAnswer = '45^\\circ';
    } else {
        const frac = toFraction(cosPhi);
        if (!frac) return generateQuestion2();
        correctAnswer = `\\arccos ${frac}`;
    }

    correct = `\\(\\varphi = ${correctAnswer}\\)`;

    const options = new Set([correct]);
    while (options.size < 4) {
        const fake = generateFakeAngle(cosPhi, correctAnswer);
        if (fake && !options.has(fake)) options.add(fake);
    }

    return {
       text: `
    <div class="prompt-text">Знайти кут між прямими</div>
    <div class="formula">
        \\[
            ${formatEq(line1.A, line1.B, line1.C)} \\quad \\text{і} \\quad ${formatEq(line2.A, line2.B, line2.C)}
        \\]
    </div>
`,
        options: Array.from(options).sort(() => Math.random() - 0.5),
        correct
    };
}

// === Хибні відповіді для кута ===
function generateFakeAngle(trueCos, trueAnswer) {
    const types = [
        () => {
            const m = trueAnswer.match(/\\arccos \\frac\{(\d+)\}\{(\d+)\}/);
            if (m) return `\\(\\varphi = \\arccos \\frac{${m[2]}}{${m[1]}}\\)`;
            return null;
        },
        () => {
            const angles = ['0^\\circ', '30^\\circ', '45^\\circ', '60^\\circ', '90^\\circ'];
            const wrong = angles[Math.floor(Math.random() * angles.length)];
            return wrong !== trueAnswer.replace(/\\arccos.*$/, '').trim()
                ? `\\(\\varphi = ${wrong}\\)` : null;
        },
        () => {
            const n = Math.floor(Math.random() * 10) + 1;
            const d = Math.floor(Math.random() * 15) + 10;
            return `\\(\\varphi = \\arccos \\frac{${n}}{${d}}\\)`;
        }
    ];

    let res;
    do { res = types[Math.floor(Math.random() * types.length)](); }
    while (!res || res === correct);
    return res;
}
    
// === Хибні відповіді для tan φ ===
function generateFakeTan() {
    const types = [
        () => {
            const m = correct.match(/\\frac\{(\d+)\}\{(\d+)\}/);
            if (m) return `\\(\\mathrm{tg} \\varphi = \\frac{${m[2]}}{${m[1]}}\\)`;
            return null;
        },
        () => `\\(\\mathrm{tg} \\varphi = \\frac{${Math.floor(Math.random()*10)+1}}{${Math.floor(Math.random()*15)+10}}\\)`,
        () => {
            const val = Math.random() * 3 + 0.1;
            const frac = toFraction(val);
            return frac ? `\\(\\mathrm{tg} \\varphi = ${frac}\\)` : null;
        }
    ];
    let res;
    do {
        res = types[Math.floor(Math.random() * types.length)]();
    } while (!res || res === correct);
    return res;
}

   // === ПИТАННЯ 3: tan φ між прямими y = kx + b ===
function generateQuestion3() {
    let k1, k2;
    do {
        k1 = randSlope();
        k2 = randSlope();
    } while (Math.abs(1 + (k1.num / k1.den) * (k2.num / k2.den)) < 1e-8);

    const b1 = randB();
    const b2 = randB();

    const k1Val = k1.num / k1.den;
    const k2Val = k2.num / k2.den;

    const tanPhi = Math.abs((k2Val - k1Val) / (1 + k1Val * k2Val));

    const frac = toFraction(tanPhi);
    if (!frac) return generateQuestion3();

    correct = `\\(\\mathrm{tg} \\varphi = ${frac}\\)`;

    const options = new Set([correct]);
    while (options.size < 4) {
        const fake = generateFakeTan();
        if (fake) options.add(fake);
    }

    return {
       text: `
    <div class="prompt-text">Знайти тангенс кута між прямими</div>
    <div class="formula">
        \\[
            ${formatSlopeEq(k1, b1)}, \\quad ${formatSlopeEq(k2, b2)}
        \\]
    </div>
`,
        options: Array.from(options).sort(() => Math.random() - 0.5),
        correct
    };
}

// === ПИТАННЯ 4: кут між прямими через arctg ===
function generateQuestion4() {
    let k1, k2;
    do {
        k1 = randSlope();
        k2 = randSlope();
    } while (Math.abs(1 + (k1.num/k1.den)*(k2.num/k2.den)) < 1e-8);

    const b1 = randB(), b2 = randB();

    const n1 = k1.num, d1 = k1.den, n2 = k2.num, d2 = k2.den;

    // Точний tan φ як дріб
    const numNum = n2 * d1 - n1 * d2;
    const numDen = d2 * d1;
    const denNum = d1 * d2 + n1 * n2;
    const denDen = d1 * d2;

    const tanNum = Math.abs(numNum * denDen);
    const tanDen = Math.abs(denNum * numDen);

    const tanFrac = makeFraction(tanNum, tanDen);
    const tanValue = tanFrac.num / tanFrac.den;

    let answer;

    // Табличні кути
    if (Math.abs(tanValue - 0) < 1e-8) {
        answer = '0^\\circ';
    } else if (Math.abs(tanValue - 1) < 1e-8) {
        answer = '45^\\circ';
    } else if (Math.abs(tanValue - Math.sqrt(3)) < 0.05) {
        answer = '60^\\circ';
    } else if (Math.abs(tanValue - 0.57735) < 0.05) { // ≈1/√3
        answer = '30^\\circ';
    } else if (tanValue > 1e8) {
        answer = '90^\\circ';
    } else {
        const fracStr = formatFraction(tanFrac);
        answer = `\\mathrm{arctg} ${fracStr}`;
    }

    correct = `\\(\\varphi = ${answer}\\)`;

    const options = new Set([correct]);
    while (options.size < 4) {
        const fake = generateFakeAngle4(tanValue, answer);
        if (fake && !options.has(fake)) options.add(fake);
    }

    return {
        text: `
    <div class="prompt-text">Знайти кут між прямими</div>
    <div class="formula">
        \\[
            ${formatSlopeEq(k1, b1)}, \\quad ${formatSlopeEq(k2, b2)}
        \\]
    </div>
`,
        options: Array.from(options).sort(() => Math.random() - 0.5),
        correct
    };
}

// === Хибні відповіді для Питання 4 ===
function generateFakeAngle4(trueTan, trueAnswer) {
    const types = [
        // 1. Перевернутий дріб у arctg
        () => {
            const m = trueAnswer.match(/\\mathrm{arctg} \\frac\{(\d+)\}\{(\d+)\}/);
            if (m) return `\\(\\varphi = \\mathrm{arctg} \\frac{${m[2]}}{${m[1]}}\\)`;
            return null;
        },
        // 2. Помилковий табличний кут
        () => {
            const angles = ['0^\\circ', '30^\\circ', '45^\\circ', '60^\\circ', '90^\\circ'];
            let wrong;
            do {
                wrong = angles[Math.floor(Math.random() * angles.length)];
            } while (wrong === trueAnswer);
            return `\\(\\varphi = ${wrong}\\)`;
        },
        // 3. arctg з випадковим дробом
        () => {
            const n = Math.floor(Math.random() * 10) + 1;
            const d = Math.floor(Math.random() * 15) + 10;
            return `\\(\\varphi = \\mathrm{arctg} \\frac{${n}}{${d}}\\)`;
        }
    ];

    let res;
    do {
        res = types[Math.floor(Math.random() * types.length)]();
    } while (!res || res === correct);

    return res;
}

    
// === Відображення ===
function displayQuestion() {
    let q;
    if (currentQuestionType === 1) q = generateQuestion1();
    else if (currentQuestionType === 2) q = generateQuestion2();
    else if (currentQuestionType === 3) q = generateQuestion3();
    else q = generateQuestion4();

    correct = q.correct;
    els.questionText.innerHTML = q.text;
    els.questionNumber.textContent = `Питання ${currentQuestionType}`;

    els.optionsContainer.innerHTML = '';
    q.options.forEach(opt => {
        const div = document.createElement('div');
        div.className = 'option';
        div.dataset.value = opt;
        div.innerHTML = opt;
        els.optionsContainer.appendChild(div);
    });

    selected = null;
    els.submitAnswer.disabled = true;
    document.querySelectorAll('.option').forEach(o => o.classList.remove('selected'));

    if (window.MathJax?.typesetPromise) {
        MathJax.typesetPromise([els.questionText, els.optionsContainer])
            .catch(err => console.error('MathJax error:', err));
    }
}
// === Ініціалізація ===
function initTrainer() {
    els.questionText.style.display = 'block';
    els.optionsContainer.style.display = 'flex';
    els.submitAnswer.style.display = 'block';
    els.questionNumber.parentElement.style.display = 'flex';

    selected = null;
    correct = null;
    displayQuestion();
}

// === Клік ===

els.optionsContainer.addEventListener('click', e => {
    const opt = e.target.closest('.option');
    if (!opt) return;
    document.querySelectorAll('.option').forEach(o => o.classList.remove('selected'));
    opt.classList.add('selected');
    selected = opt.dataset.value;
    els.submitAnswer.disabled = false;
});
    // Покращена обробка кліків для карток питань
// Додатковий код для поліпшення роботи флеш-карток
document.addEventListener('DOMContentLoaded', function() {
    // Обробка кліків на картки
    document.querySelectorAll('.question-card').forEach(card => {
        // Для десктопів
        card.addEventListener('click', function(e) {
            // Перевіряємо, що клік не на математичній формулі
            if (!e.target.closest('mjx-container')) {
                this.classList.toggle('flipped');
            }
        });
        
        // Для мобільних пристроїв
        card.addEventListener('touchstart', function(e) {
            this.style.transform = 'scale(0.98)';
        }, { passive: true });
        
        card.addEventListener('touchend', function(e) {
            this.style.transform = 'scale(1)';
            setTimeout(() => {
                this.classList.toggle('flipped');
            }, 50);
        }, { passive: true });
    });
    
    // Запобігаємо закриттю модального вікна при кліку на картку
    document.getElementById('questionsModal').addEventListener('click', function(e) {
        if (e.target.classList.contains('question-card') || 
            e.target.closest('.question-card')) {
            e.stopPropagation();
        }
    });
});

// Додатково: покращена обробка для варіантів відповідей у тренажері
document.addEventListener('touchstart', function(e) {
    if (e.target.classList.contains('option')) {
        e.target.classList.add('touched');
    }
}, { passive: true });

document.addEventListener('touchend', function(e) {
    if (e.target.classList.contains('option')) {
        e.target.classList.remove('touched');
    }
}, { passive: true });


// === Підтвердження відповіді ===
els.submitAnswer.addEventListener('click', () => {
    const isCorrect = selected === correct;
    els.feedback.textContent = isCorrect ? '✓ Ціль уражена!' : '✗ Промах! Спробуй ще!';
    els.feedback.className = `feedback ${isCorrect ? 'correct-feedback' : 'incorrect-feedback'} show`;

    setTimeout(() => {
        els.feedback.classList.remove('show');
        setTimeout(() => {
            if (isCorrect) {
                if (currentQuestionType < 4) {
                    currentQuestionType++;
                    displayQuestion();
                } else {
                    toggleModal(els.trainerModal, false);
                    toggleModal(els.completionModal, true);
                }
            } else {
                displayQuestion();
            }
        }, 300);
    }, 1000);
});

// === Повернення → Питання 1 ===
els.resetTrainerBtn.addEventListener('click', () => {
    toggleModal(els.completionModal, false);
    toggleModal(els.trainerModal, true);
    currentQuestionType = 1;
    initTrainer();
});
});
</script>
</body>
</html>

