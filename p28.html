<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>28. Лінійні операції над векторами</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --base-font-size: 16px;
            --text-color: #F5F5F5;
            --math-color: #FFD700;
            --accent-color: #ffa500;
            --bg-gradient: linear-gradient(135deg, #2E5C5A, #4A7C59);
            --bg-hover: linear-gradient(135deg, #5D9A86, #F4A261);
            --card-bg: #3A6F65;
            --success-color: #90EE90;
            --error-color: #FFB6C1;
        }
        *, *:before, *:after {
            box-sizing: border-box;
        }
      body {
    margin: 0;
    padding: 0;
    background: var(--bg-gradient);
    font-family: 'Roboto', sans-serif;
    color: var(--text-color);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: start;
    min-height: 100dvh;
    font-size: 1rem;
}
.title-box {
    margin-top: 60px;
    padding: 25px 40px;
    background: var(--bg-gradient);
    border-radius: 25px;
    box-shadow: 0 8px 18px rgba(0, 0, 0, 0.2);
    max-width: 90%;
    text-align: center;
    border: 1px solid rgba(255, 255, 255, 0.2);
}
.title-box h1 {
    margin: 0;
    font-size: 1.75rem;
    color: var(--text-color);
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    font-family: 'Lora', serif;
}
.section-container {
    margin-top: 40px;
    display: flex;
    flex-wrap: wrap;
    gap: 30px;
    justify-content: center;
}
.section {
    width: 250px;
    height: 220px;
    background: var(--card-bg);
    border-radius: 20px;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 20px;
    transition: transform 0.3s ease;
    cursor: pointer;
    text-decoration: none;
    color: var(--text-color);
    border: 1px solid rgba(255, 255, 255, 0.3);
}
.section:hover {
    transform: translateY(-5px);
    background: var(--bg-hover);
}
.section img {
    width: 60px;
    height: 60px;
    margin-bottom: 15px;
    object-fit: cover;
    border-radius: 8px;
    filter: brightness(1.2);
}
.section h2 {
    font-size: 1.25rem;
    color: var(--text-color);
    margin: 0;
    font-family: 'Lora', serif;
}
.navigation-buttons {
    display: flex;
    justify-content: center;
    gap: 20px;
    flex-wrap: wrap;
    margin: 40px auto;
    max-width: 1000px;
    padding: 0 20px;
}
.nav-button {
    display: flex;
    align-items: center;
    background: var(--card-bg);
    color: var(--text-color);
    text-decoration: none;
    padding: 12px 24px;
    border-radius: 12px;
    font-size: 1.125rem;
    font-weight: bold;
    transition: all 0.3s ease;
    box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.2);
    border: 2px solid var(--text-color);
    line-height: 1.2;
}
.nav-button:hover {
    background: var(--bg-hover);
    color: var(--text-color);
    transform: scale(1.05);
}
.nav-button svg {
    margin-right: 8px;
    fill: currentColor;
    width: 20px;
    height: 20px;
}
.modal {
    display: none;
    position: fixed;
    top: 5%;
    left: 5%;
    width: 90%;
    height: 90%;
    background: var(--card-bg);
    border-radius: 15px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    overflow: hidden;
    flex-direction: column;
}
.modal-content {
    padding: 20px;
    overflow-y: auto;
    flex-grow: 1;
    background: var(--card-bg);
    border-radius: 10px;
    margin: 10px;
    width: 100%;
    color: var(--text-color);
}
.modal-header {
    display: flex;
    justify-content: flex-end;
    background: var(--bg-gradient);
    padding: 8px 10px;
    border-top-left-radius: 15px;
    border-top-right-radius: 15px;
}
.close-btn {
    background: var(--text-color);
    color: #2E5C5A;
    border: none;
    border-radius: 6px;
    padding: 5px 15px;
    font-size: 1rem;
    cursor: pointer;
    transition: background 0.3s ease;
}
.close-btn:hover {
    background: var(--accent-color);
}
#modalOverlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.5);
    z-index: 999;
}
.tab-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-bottom: 20px;
}
.tab-button {
    background: var(--bg-gradient);
    color: var(--text-color);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    padding: 10px 20px;
    font-family: 'Lora', serif;
    font-size: 1.125rem;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: left;
    position: relative;
}
.tab-button::after {
    content: '▶';
    position: absolute;
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 1rem;
    color: var(--text-color);
    transition: transform 0.3s ease;
}
.tab-button.active::after {
    content: '▼';
    transform: translateY(-50%);
}
.tab-button.active {
    background: var(--bg-hover);
    color: var(--accent-color);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}
.tab-button:hover {
    background: var(--bg-hover);
    transform: translateY(-2px);
}
.tab-content {
    display: none;
    padding: 20px;
    border-radius: 10px;
    background: var(--card-bg);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.4);
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease-out;
    width: 100%;
    box-sizing: border-box;
}
.tab-content.active {
    display: block;
    max-height: none;
    overflow-y: auto;
}
#theoryModal .modal-content p {
    text-align: justify;
    color: var(--text-color);
    font-size: 1.125rem;
    line-height: 1.6;
    white-space: normal;
}
#theoryModal .modal-content h3 {
    font-family: 'Lora', serif;
    font-size: 1.5rem;
    color: var(--accent-color);
    margin-bottom: 15px;
    text-align: center;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
}
#theoryModal .modal-content .example-title {
    color: var(--accent-color);
    font-weight: bold;
    font-size: 1.25rem;
    margin-bottom: 10px;
}
#theoryModal .modal-content .example-solution {
    color: var(--accent-color);
    font-weight: bold;
    font-size: 1.125rem;
    text-align: left;
    margin: 15px 0;
}
#theoryModal .modal-content li {
    color: var(--text-color);
    padding-left: 20px;
    margin-left: 10px;
    max-width: calc(100% - 30px);
    white-space: normal;
    text-align: justify;
    position: relative;
    font-size: 1.125rem;
}
.MathJax, mjx-container, mjx-math, mjx-mrow {
    color: var(--math-color) !important;
    font-size: 1.3rem !important;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
}
mjx-msub {
    font-size: 1.1em !important;
}
mjx-container[jax="CHTML"][display="true"] {
    display: block !important;
    text-align: center !important;
    overflow-x: auto !important;
    overflow-y: hidden !important;
    white-space: nowrap;
    max-width: 100%;
    margin: 0 auto !important;
    padding: 5px;
    -webkit-overflow-scrolling: touch;
}
.flashcard-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin-top: 20px;
    max-width: 800px;
    margin-left: auto;
    margin-right: auto;
}
.flashcard {
    perspective: 1000px;
    width: 100%;
    height: 200px;
    cursor: pointer;
    outline: none;
}
.flashcard-inner {
    position: relative;
    width: 100%;
    height: 100%;
    transition: transform 0.6s;
    transform-style: preserve-3d;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    border-radius: 15px;
}
.flashcard.flipped .flashcard-inner {
    transform: rotateY(180deg);
}
.flashcard-front, .flashcard-back {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    border-radius: 15px;
    box-sizing: border-box;
    background: #4f7942;
    color: var(--text-color);
}
.flashcard-back {
    transform: rotateY(180deg);
    background: #40826d;
    color: var(--text-color);
    text-align: justify;
}
.flashcard-front p, .flashcard-back p {
    font-size: 1.4rem;
    margin: 0;
    font-family: 'Lora', serif;
    line-height: 1.5;
    text-align: center;
}
.flashcard-back p {
    font-family: 'Roboto', sans-serif;
    font-size: 1.4rem;
    line-height: 1.6;
    text-align: left;
    white-space: normal;
}
.flashcard-back ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
}
.flashcard-back li {
    color: var(--accent-color);
    margin: 5px 0;
    font-size: 1.125rem;
    text-align: left;
}
.trainer-container {
    width: 95%;
    max-width: 900px;
    padding: 4vw 5vw;
    text-align: center;
    background: linear-gradient(135deg, #2e4c5a, #4c6b7a);
    border-radius: 16px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
    border: 1px solid rgba(163, 166, 139, 0.3);
    box-sizing: border-box;
    margin: auto;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: rgba(163, 166, 139, 0.5) transparent;
}
.question-circle {
    width: clamp(80px, 15vw, 120px);
    height: clamp(80px, 15vw, 120px);
    margin: 0 auto 3vw;
    border-radius: 50%;
    background: var(--bg-gradient, #FF8C00);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
    display: flex;
    justify-content: center;
    align-items: center;
}
.question-circle h3 {
    font-family: 'Lora', serif;
    font-size: clamp(1.0rem, 2.8vw, 1.2rem);
    color: var(--math-color, white);
    margin: 0;
    padding: 0;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    text-align: center;
    line-height: 1;
}
#questionText {
    font-family: 'Lora', serif;
    font-size: 1.125rem;
    color: var(--text-color, black);
    line-height: 1.6;
    margin: 10px 0;
    text-align: center;
}
#questionText .MathJax, #questionText mjx-container, #questionText mjx-math, #questionText mjx-mrow {
    color: var(--math-color, black) !important;
    font-size: 1.3rem !important;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
}
#matrixText {
    margin: 40px 0;
    text-align: center;
}
#matrixText img, #vectorCanvas {
    max-width: 300px;
    max-height: 350px;
    display: block;
    margin: 0 auto;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}
#vectorCanvas {
    overflow: hidden;
}
.vectorCanvasWrapper {
    position: relative;
    width: 300px;
    height: 300px;
    margin: 0 auto;
    overflow: hidden;
}
.answer-options {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
    margin: 30px 0;
    justify-items: center;
    width: 100%;
    max-width: 900px;
}
.answer-button {
    background: var(--bg-gradient, white);
    color: var(--text-color, black);
    border: 2px solid var(--accent-color, #FF8C00);
    border-radius: 8px;
    padding: 15px 30px;
    font-family: 'Roboto', sans-serif;
    font-size: 1.5rem;
    cursor: pointer;
    transition: background 0.3s ease, transform 0.2s ease;
    width: 100%;
    max-width: 300px;
    text-align: center;
    margin: 5px;
    box-sizing: border-box;
}
.answer-button:hover:not(:disabled) {
    background: var(--bg-hover, rgba(255, 140, 0, 0.1));
    transform: scale(1.02);
}
.answer-button.selected {
    background: var(--accent-color, #FF8C00);
    color: #2E5C5A;
}
.answer-button.correct {
    background: var(--success-color, rgba(0, 128, 0, 0.2));
    color: #2E5C5A;
}
.answer-button.wrong {
    background: var(--error-color, rgba(255, 0, 0, 0.2));
    color: #2E5C5A;
}
.answer-button:disabled {
    background: #7F8C8D;
    cursor: not-allowed;
}
.answer-button .MathJax, .answer-button mjx-container, .answer-button mjx-math, .answer-button mjx-mrow {
    color: var(--math-color, black) !important;
    font-size: 1.3rem !important;
}
#submitAnswerBtn {
    background: #7F8C8D;
    color: var(--text-color, white);
    border: none;
    border-radius: 8px;
    padding: 10px 20px;
    font-family: 'Roboto', sans-serif;
    font-size: 1rem;
    cursor: not-allowed;
    transition: background 0.3s ease;
    margin: 10px auto;
    display: block;
}
#submitAnswerBtn.active {
    background: var(--accent-color, #FF8C00);
    color: #2E5C5A;
    cursor: pointer;
}
#submitAnswerBtn.active:hover {
    background: var(--bg-hover, rgba(255, 140, 0, 0.8));
}
.result-message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.5rem;
    font-family: 'Lora', serif;
    font-weight: bold;
    text-align: center;
    padding: 20px 40px;
    border-radius: 12px;
    min-width: 300px;
    background: var(--card-bg, white);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    opacity: 0;
    transition: opacity 0.5s ease;
    z-index: 1001;
    display: none;
}
.result-message.correct {
    color: #2E5C5A;
    background: var(--success-color, rgba(0, 128, 0, 0.2));
    opacity: 1;
}
.result-message.wrong {
    color: #2E5C5A;
    background: var(--error-color, rgba(255, 0, 0, 0.2));
    opacity: 1;
}
.completion-emoji {
    width: clamp(80px, 15vw, 120px);
    height: clamp(80px, 15vw, 120px);
    margin: 0 auto 3vw;
    border-radius: 50%;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
    border: 2px dashed var(--accent-color, #FF8C00);
    display: flex;
    justify-content: center;
    align-items: center;
}
.completion-emoji::after {
    content: '🎉';
    font-size: clamp(40px, 8vw, 60px);
    color: var(--math-color, black);
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100%;
}
.completion-message {
    display: none;
    text-align: center;
    padding: 20px;
    background: var(--card-bg, white);
    border-radius: 15px;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
    margin: 20px auto;
    max-width: 600px;
    color: var(--text-color, black);
}
.completion-message h2 {
    font-family: 'Lora', serif;
    font-size: 1.75rem;
    color: var(--math-color, #FF8C00);
    text-align: center;
    margin: 10px 0;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
}
.completion-message p {
    font-family: 'Roboto', sans-serif;
    font-size: 1.5rem;
    color: var(--accent-color, #FF8C00);
    text-align: center;
    margin: 10px 0;
    font-weight: bold;
}
#resetTrainerBtn {
    display: block;
    margin: 20px auto;
    padding: 12px 24px;
    font-size: 18px;
    font-weight: bold;
    color: var(--text-color, white);
    background: var(--bg-gradient, #FF8C00);
    border: none;
    border-radius: 25px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}
#resetTrainerBtn:hover {
    background: var(--bg-hover, rgba(255, 140, 0, 0.8));
    transform: scale(1.05);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
}
#resetTrainerBtn:active {
    transform: scale(0.95);
}
.video-card-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 20px;
    padding: 20px;
}
.video-card {
    width: 350px;
    height: 250px;
    background: var(--card-bg);
    border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 10px;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    cursor: pointer;
    color: var(--text-color);
}
.video-card:hover {
    transform: scale(1.05);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
}
.video-card img {
    width: 40px;
    height: 40px;
    margin-bottom: 8px;
    object-fit: cover;
    border-radius: 6px;
}
.video-player-container {
    width: 80vw;
    max-width: 960px;
    aspect-ratio: 16 / 9;
    margin: 20px auto;
    display: flex;
    justify-content: center;
    align-items: center;
}
.video-player-container iframe {
    width: 100%;
    height: 100%;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    display: block;
    border: none;
}
.video-card h3 {
    font-size: clamp(16px, 2.5vw, 18px);
    font-weight: 600;
    color: var(--text-color);
}
.glow-title {
    font-family: 'Lora', serif;
    font-size: 1.5rem;
    color: var(--math-color);
    text-align: center;
    margin-bottom: 20px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
}
.math-loading {
    visibility: hidden;
    opacity: 0;
    transition: opacity 0.3s ease;
}
.math-loaded {
    visibility: visible;
    opacity: 1;
}
.vector-label, .vector-label * {
    color: red !important;
    fill: red !important;
}
@media (min-width: 769px) {
    .answer-button {
        padding: 20px 40px;
        max-width: 350px;
        font-size: 1.75rem;
    }
    .answer-button .MathJax, .answer-button mjx-container, .answer-button mjx-math, .answer-button mjx-mrow {
        font-size: 1.5rem !important;
    }
}
@media (max-width: 768px) {
    .title-box { margin-top: 40px; padding: 15px 20px; }
    .title-box h1 { font-size: 1.5rem; }
    .section-container { flex-direction: column; align-items: center; gap: 20px; }
    .section { width: 80%; height: 180px; }
    .section h2 { font-size: 1.125rem; }
    .nav-button { font-size: 0.9rem; padding: 8px 16px; }
    .tab-button { font-size: 1rem; padding: 8px 10px; }
    .tab-content { padding: 15px; }
    .modal { top: 2%; left: 2%; width: 96%; height: 96%; }
    .trainer-container { width: 95%; padding: 4vw; }
    .answer-options { grid-template-columns: 1fr; gap: 0.75rem; }
    .video-card-container {
        flex-direction: column;
        gap: 15px;
        padding: 15px;
    }
    .video-card {
        width: 260px;
        height: 160px;
        margin: 5px;
    }
    .video-card img {
        width: 40px;
        height: 40px;
        margin-bottom: 6px;
    }
    .video-player-container {
        width: 80vw;
        max-width: 600px;
        aspect-ratio: 16 / 9;
    }
    .video-card h3 {
        font-size: clamp(14px, 2.5vw, 16px);
    }
    .flashcard-front p {
        font-size: 1.125rem;
    }
    .flashcard-back p {
        font-size: 1rem;
    }
    .flashcard {
        height: 180px;
    }
    .flashcard-front, .flashcard-back {
        padding: 15px;
    }
    #theoryModal .modal-content li {
        padding-left: 7px;
        margin-left: 5px;
        max-width: calc(100% - 15px);
    }
    .flashcard {
        height: 220px;
    }
    #matrixText img {
        max-width: 250px;
    }
    .answer-options {
        grid-template-columns: 1fr;
        gap: 0.75rem;
    }
    .answer-button {
        font-size: 1.0rem;
        padding: 10px 20px;
        max-width: 250px;
    }
    .answer-button .MathJax, .answer-button mjx-container, .answer-button mjx-math, .answer-button mjx-mrow {
        font-size: 1.1rem !important;
    }
}
@media (max-width: 480px) {
    .title-box { margin-top: 20px; padding: 10px 15px; }
    .title-box h1 { font-size: 1.25rem; }
    .section { width: 90%; height: 150px; }
    .section img { width: 50px; height: 50px; }
    .section h2 { font-size: 1rem; }
    .video-card-container {
        gap: 10px;
        padding: 10px;
    }
    .video-card {
        width: 90%;
        max-width: 260px;
        height: 140px;
        margin: 5px;
    }
    .video-card img {
        width: 30px;
        height: 30px;
        margin-bottom: 5px;
    }
    .video-card h3 {
        font-size: clamp(12px, 2.5vw, 14px);
    }
    .video-player-container {
        width: 80vw;
        max-width: 400px;
        aspect-ratio: 16 / 9;
    }
    #theoryModal .modal-content h3 { font-size: 1.25rem; }
    .example-title { font-size: 1.0rem; }
    .example-solution { font-size: 1.0rem; }
    .MathJax, mjx-container, mjx-math, mjx-mrow { font-size: 1.2rem !important; }
    .question-circle { width: clamp(80px, 15vw, 100px); height: clamp(80px, 15vw, 100px); }
    .question-circle h3 { font-size: clamp(0.9rem, 2.5vw, 1.0rem); }
    .answer-button { font-size: 1.0rem; }
    .answer-button {
        font-size: 0.9rem;
        padding: 8px 16px;
        max-width: 220px;
    }
    .answer-button .MathJax, .answer-button mjx-container, .answer-button mjx-math, .answer-button mjx-mrow {
        font-size: 1.0rem !important;
    }
}
@media (max-width: 320px) {
    .flashcard-front p, .flashcard-back p {
        font-size: 0.9rem;
    }
    .answer-button {
        font-size: 0.8rem;
        padding: 6px 12px;
        max-width: 200px;
    }
    .answer-button .MathJax, .answer-button mjx-container, .answer-button mjx-math, .answer-button mjx-mrow {
        font-size: 0.9rem !important;
    }
}
    </style>
</head>
<body>
    <div class="title-box">
        <h1>28. Лінійні операції над векторами</h1>
    </div>
    <div class="section-container">
        <div class="section" id="openTheoryBtn">
            <img src="https://img.icons8.com/fluency/96/book-shelf.png" alt="Книга" loading="lazy">
            <h2>Теоретичні відомості</h2>
        </div>
        <div class="section" id="openVideoBtn">
            <img src="https://img.icons8.com/fluency/96/video.png" alt="Відео" loading="lazy">
            <h2>Відеоматеріали</h2>
        </div>
        <div class="section" id="openQuestionsBtn">
            <img src="https://img.icons8.com/fluency/96/flipboard.png" alt="Картки" loading="lazy">
            <h2>Питання і відповіді</h2>
        </div>
        <div class="section" id="openTrainerBtn">
            <img src="https://img.icons8.com/fluency/96/flash-on.png" alt="Тренажер" loading="lazy">
            <h2>Тренажер</h2>
        </div>
    </div>
    <div class="navigation-buttons">
        <a class="nav-button" href='tema7.html'>
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24">
                <path d="M15 18l-6-6 6-6"/>
            </svg>
            До теми 7
        </a>
        <a class="nav-button" href='index.html'>
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24">
                <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
            </svg>
            На головну
        </a>
    </div>
    <div id="modalOverlay"></div>
    <div id="theoryModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
        <div class="modal-header">
            <button class="close-btn" aria-label="Закрити документ" id="closeTheoryBtn">× Закрити</button>
        </div>
        <div class="modal-content">
            <div class="tab-container">
                <button class="tab-button" data-tab="vector-addition" aria-expanded="false">Додавання і віднімання векторів</button>
                <div id="vector-addition" class="tab-content">
    
    <p>Лінійні операції над векторами – це базові дії, які виконуються з векторами в геометричній формі. Ці операції включають: додавання, віднімання векторів та множення вектора на скаляр (число).</p>

    <h3>Додавання векторів</h3>
    
    <p>
  <span style="color:#ffbf00; font-weight:bold;">Правило трикутника.</span> 
  Геометрично додавання векторів відповідає правилу трикутника. 
  Нехай задано два вектори \(\vec{a}\) і \(\vec{b}\) (рис. 7.6).
</p>

 <img src="/static/figure7.6.jpg" alt="Правило трикутника для додавання векторів" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
    
   <p>  Щоб знайти їхню суму, перенесемо вектор \(\vec{b}\) так, щоб його початок збігався з кінцем вектора \(\vec{a}\). Далі проведемо вектор \(\vec{c}\) від початку вектора \(\vec{a}\) до кінця вектора \(\vec{b}\) (рис. 7.7).
   Отриманий вектор \(\vec{c}\) є результатом додавання \(\vec{a} + \vec{b}\).</p>
    <img src="/static/figure7.7.jpg" alt="Результат додавання векторів за правилом трикутника" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
      <p>Для кращого розуміння розглянемо фізичний приклад: нехай тіло спочатку перемістилося за вектором \(\vec{a}\), а потім за вектором \(\vec{b}\). Тоді його загальне переміщення описується вектором \(\vec{c}\), який вказує напрямок і величину сумарного переміщення – від початкової до кінцевої точки.</p>
    <p style="color:#ffefd5;"><strong>Примітка:</strong> <em>Правило трикутника застосовується до будь-якої кількості векторів. Вони з’єднуються послідовно: кінець одного
    збігається з початком наступного. Сумарний вектор – це вектор, що сполучає початок першого вектора з кінцем останнього (рис. 7.8).</p> </em>
    <img src="/static/figure7.8.jpg" alt="Додавання кількох векторів за правилом трикутника" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
    
    <p>
  <span style="color:#ffbf00; font-weight:bold;">Правило паралелограма.</span> 
    Нехай задано два вектори \(\vec{a}\) і \(\vec{b}\) (рис. 7.9). Відкладемо обидва вектори від однієї спільної точки. Далі добудуємо паралелограм, провівши сторони, паралельні векторам \(\vec{a}\) і \(\vec{b}\). Діагональ цього паралелограма, що починається від спільної точки і спрямована до протилежної вершини, є сумою векторів \(\vec{a} + \vec{b}\).</p>
    <img src="/static/figure7.9.jpg" alt="Правило паралелограма для додавання векторів" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
    
  <p>
  <span style="color:#ffbf00; font-weight:bold;">Правило паралелепіпеда.</span> 
  Сума трьох некомпланарних векторів \(\vec{a}\), \(\vec{b}\) і \(\vec{c}\), що виходять із однієї точки (рис. 7.10), дорівнює діагоналі паралелепіпеда, побудованого на цих векторах із цієї ж точки (рис. 7.11). Для цього вектори приводять до спільного початку в точці \(O\), а на них як на ребрах будують паралелепіпед. Діагональ цього паралелепіпеда, що сполучає точку \(O\) з протилежною вершиною, геометрично зображує результуючий вектор \(\vec{a} + \vec{b} + \vec{c}\).
</p>
 <img src="/static/figure7.10.jpg" alt="Три некомпланарні вектори"  style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
    
     <h3>Різниця векторів</h3>
        <p>
  <span style="color:#ffbf00; font-weight:bold;">Правило трикутника.</span>
  Різницею векторів \(\vec{a}\) і \(\vec{b}\) називається вектор \(\vec{c}\), що сполучає кінець вектора \(\vec{b}\) з кінцем вектора \(\vec{a}\) за умови, що обидва вектори мають спільний початок. Іншими словами, \(\vec{c} = \vec{a} - \vec{b}\) вказує напрямок і величину переміщення від кінця вектора \(\vec{b}\) до кінця вектора \(\vec{a}\). Геометрично це можна представити через правило трикутника: якщо \(\vec{a} = \vec{b} + \vec{c}\), то \(\vec{c} = \vec{a} - \vec{b}\) (рис. 7.12).</p>
    <img src="/static/figure7.12.jpg" alt="Правило трикутника для віднімання векторів" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
    
     <p>
  <span style="color:#ffbf00; font-weight:bold;">Правило паралелограма.</span>
  Геометрично віднімання вектора \(\vec{b}\) від \(\vec{a}\) можна уявити як додавання вектора \(\vec{a}\) до вектора \(-\vec{b}\). Для цього будуємо протилежний вектор \(-\vec{b}\) до вектора \(\vec{b}\) (рис. 7.13). Потім за правилом паралелограма додаємо вектори \(\vec{a} + (-\vec{b})\). Початок отриманого вектора необхідно перенести паралельно в кінець вектора \(\vec{b}\). Отриманий вектор \(\vec{a} - \vec{b}\) є різницею векторів \(\vec{a}\) і \(\vec{b}\).</p>
    <img src="/static/figure7.13.jpg" alt="Правило паралелограма для віднімання векторів" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
</div>

                <button class="tab-button" data-tab="vector-scaling" aria-expanded="false">Множення вектора на число</button>
               <div id="vector-scaling" class="tab-content">
    <h3>Множення вектора на число</h3>
    <p>Множення ненульового вектора \(\vec{a}\) на число \(\lambda\) дає новий вектор \(\vec{b}\), довжина якого визначається як \(|\vec{b}| = |\lambda| \cdot |\vec{a}|\), а напрямок залежить від знака \(\lambda\):</p>
    <ul>
        <li>якщо \(\lambda \geq 0\), то \(\vec{b}\) співнапрямлений із \(\vec{a}\);</li>
        <li>якщо \(\lambda < 0\), то \(\vec{b}\) має протилежний напрямок до \(\vec{a}\).</li>
    </ul>
    <p>На рисунку 7.14 показано, як вектор змінює свою довжину залежно від \(|\lambda|\) та напрямок залежно від знака \(\lambda\). Наприклад, якщо \(|\lambda| < 1\), то довжина вектора зменшується в \(|\lambda|\) разів. Так, довжина вектора \(\vec{b} = \frac{1}{2} \vec{a}\) удвічі менша за довжину вектора \(\vec{a}\). Якщо \(|\lambda| > 1\), довжина вектора збільшується у \(|\lambda|\) разів. Зокрема, довжина вектора \(\vec{e} = \sqrt{2} \vec{a}\) у \(\sqrt{2}\) рази більша за довжину вектора \(\vec{a}\).</p>

    <p>Усі отримані вектори є колінеарними, оскільки один вектор можна виразити через інший за допомогою множення на число.
   <em><strong style="color: #f4c430;">Зворотне також справедливе:</strong></em>  якщо один вектор можна виразити через інший, то такі вектори обов’язково колінеарні. Таким чином, множення вектора на число завжди дає вектор, колінеарний початковому.</p>
    <p>На рисунку (рис. 7.14) вектори \(\vec{a}\), \(\vec{b}\), \(\vec{e}\) співнапрямлені між собою, а вектори \(\vec{c}\) і \(\vec{d}\) також співнапрямлені між собою, але мають протилежний напрямок до векторів \(\vec{a}\), \(\vec{b}\), \(\vec{e}\).</p>
<img src="/static/figure7.14.jpg" alt="Множення вектора на число" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">

    <p>Таким чином, множення вектора на число завжди зберігає колінеарність із початковим вектором, змінюючи лише його довжину та, можливо, напрямок.</p>
    
    <h3>Властивості лінійних дій над векторами</h3>
   
        <li>
            <strong><em>1. Комутативна (переставна) властивість</strong></em> (рис. 7.15).<br>
            Для будь-яких векторів \(\vec{a}\) і \(\vec{b}\):<br>
            <p class="math-equation center">\[\vec{a} + \vec{b} = \vec{b} + \vec{a}\]</p>
            Ця властивість показує, що вектори можна додавати в будь-якому порядку. На рисунку (рис. 7.15) це видно за правилом паралелограма: діагональ паралелограма залишається незмінною незалежно від того, який вектор додається першим.
            <img src="/static/figure7.15.jpg" alt="Комутативна властивість додавання векторів" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
        </li>
        <li>
            <strong><em>2. Асоціативна (сполучна) властивість</strong> </em>(рис. 7.16 та рис. 7.17).<br>
            Для будь-яких векторів \(\vec{a}\), \(\vec{b}\) і \(\vec{c}:\)<br>
            <p class="math-equation center">\[(\vec{a} + \vec{b}) + \vec{c} = \vec{a} + (\vec{b} + \vec{c})\]</p>
            Завдяки асоціативності додавання векторів суму трьох або більше векторів можна записувати без дужок. Наприклад, вирази \((\vec{a} + \vec{b}) + \vec{c}\) і \(\vec{a} + (\vec{b} + \vec{c})\) еквівалентні, тому їх записують як \(\vec{a} + \vec{b} + \vec{c}\).
            <div class="image-row">

<img src="/static/figure7.16.jpg" alt="Асоціативна властивість: перший крок додавання" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
                                                 </div>
        </li>
        <li>
            <strong><em>3. Додавання нульового вектора.</strong></em><br>
            Додавання нульового вектора \(\vec{0}\) до будь-якого вектора \(\vec{a}\) не змінює його:<br>
            <p class="math-equation center">\[\vec{a} + \vec{0} = \vec{a}\]</p>
        </li>
        <li>
            <strong><em>4. Сума вектора та його протилежного вектора.</strong></em><br>
            Сума вектора \(\vec{a}\) і протилежного йому вектора \(-\vec{a}\) дорівнює нульовому вектору:<br>
            <p class="math-equation center">\[\vec{a} + (-\vec{a}) = \vec{0}\]</p>
        </li>
        <li>
            <strong><em>5. Множення вектора на одиницю.</strong></em><br>
            Множення вектора \(\vec{a}\) на число 1 залишає вектор незмінним:<br>
            <p class="math-equation center">\[1 \cdot \vec{a} = \vec{a}\]</p>
        </li>
        <li>
            <strong><em>6. Асоціативна (сполучна) властивість множення на числа.</strong></em><br>
            Для будь-яких чисел \(\lambda\) і \(\mu\) та вектора \(\vec{a}\):<br>
            <p class="math-equation center">\[\lambda (\mu \vec{a}) = \lambda \mu \vec{a}\]</p>
            Множення вектора на два числа можна виконувати в будь-якому порядку, спочатку помноживши числа між собою.
        </li>
        <li>
            <strong><em>7. Дистрибутивна (розподільна) властивість щодо числових множників.</strong></em><br>
            Для будь-яких чисел \(\lambda\) і \(\mu\) та вектора \(\vec{a}\):<br>
            <p class="math-equation center">\[(\lambda + \mu) \cdot \vec{a} = \lambda \vec{a} + \mu \vec{a}\]</p>
            Сума чисел, помножена на вектор, дорівнює сумі векторів, отриманих множенням цього вектора на кожне число окремо.
        </li>
        <li>
            <strong><em>8. Дистрибутивна (розподільна) властивість щодо векторних доданків.</strong></em><br>
            Для будь-якого числа \(\mu\) та векторів \(\vec{a}\) і \(\vec{b}\):<br>
            <p class="math-equation center">\[\mu \cdot (\vec{a} + \vec{b}) = \mu \vec{a} + \mu \vec{b}\]</p>
            Число, помножене на суму векторів, дорівнює сумі векторів, кожен із яких помножений на це число.
        </li>
   
</div>

                
                <button class="tab-button" data-tab="examples" aria-expanded="false">Приклади</button>
                <div id="examples" class="tab-content">
 <p>
  <span style="color:#ffbf00; font-weight:bold;">Приклад 7.1.</span> 
    За даними векторами \(\vec{a}\) і \(\vec{b}\) (рис. 7.18) побудувати вектори:
     а) \(\vec{c} = 2\vec{a} + 3\vec{b}\); б) \(\vec{d} = 2\vec{b} - \vec{a}\).
</p>
<img src="/static/figure7.18.jpg" alt="Дані вектори a і b" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
         <h3>Розв’язання</h3>
    <p><strong>а)</strong> Вектор \(\vec{c} = 2\vec{a} + 3\vec{b}\) будуємо за правилом паралелограма. Спочатку знаходимо вектор \(2\vec{a}\), який у два рази довший за \(\vec{a}\) і співнапрямлений із ним. Далі знаходимо вектор \(3\vec{b}\), який у три рази довший за \(\vec{b}\) і також співнапрямлений із ним. Потім додаємо вектори \(2\vec{a}\) і \(3\vec{b}\), застосовуючи правило паралелограма. Результат побудови зображено на рисунку 7.19.</p>

<img src="/static/figure7.19.jpg" alt="Результат побудови вектора c = 2a + 3b" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
   

 <p><strong>б)</strong> Вектор \(\vec{d} = 2\vec{b} - \vec{a}\) будуємо аналогічно. Спочатку знаходимо вектор \(2\vec{b}\), який у два рази довший за \(\vec{b}\) і співнапрямлений із ним. Далі знаходимо вектор \(-\vec{a}\), який є протилежним до \(\vec{a}\), тобто має той самий розмір, але протилежний напрямок. Після цього додаємо вектори \(2\vec{b}\) і \(-\vec{a}\), використовуючи правило паралелограма. Результат побудови зображено на рисунку 7.20.</p>
    <div class="image-row">
<img src="/static/figure7.20.jpg" alt="Результат побудови вектора d = 2b - a" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
       </div>

    <p>
  <span style="color:#ffbf00; font-weight:bold;">Приклад 7.2.</span>
 У трикутнику \(ABC\) проведено медіану \(AM\) (рис. 7.21). Потрібно виразити вектор \(\overrightarrow{AM}\) через вектори \(\overrightarrow{AB} = \vec{b}\) і \(\overrightarrow{AC} = \vec{c}\).</p>
<img src="/static/figure7.21.jpg" alt="Медіана AM у трикутнику ABC" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
      
    <h3>Розв’язання</h3>
    <p>Щоб знайти вектор \(\overrightarrow{AM}\), добудуємо трикутник \(ABC\) до паралелограма \(ABCD\) (рис. 7.22).</p>
<img src="/static/figure7.22.jpg" alt="Паралелограм ABCD для знаходження вектора AM" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
      
    <p>У паралелограмі \(ABCD\) вектор \(\overrightarrow{AD}\) є діагоналлю, а за правилом паралелограма він дорівнює сумі векторів \(\overrightarrow{AB}\) і \(\overrightarrow{AC}\):</p>
    <p class="math-equation center">\[\overrightarrow{AD} = \overrightarrow{AB} + \overrightarrow{AC} = \vec{b} + \vec{c}\]</p>
    <p>Оскільки \(AM\) – медіана трикутника \(ABC\), точка \(M\) є серединою сторони \(BC\). У паралелограмі \(ABCD\) діагональ \(AD\) проходить через точку \(M\), яка ділить її навпіл, тобто \(\overrightarrow{AD} = 2\overrightarrow{AM}\). Отже:</p>
    <p class="math-equation center">\[2\overrightarrow{AM} = \overrightarrow{AD} = \vec{b} + \vec{c}\]</p>
    <p>Звідси, вираз для вектора медіани буде таким:</p>
    <p class="math-equation center">\[\overrightarrow{AM} = \frac{1}{2} (\vec{b} + \vec{c})\]</p>
    <p class="example-solution">Відповідь: \(\overrightarrow{AM} = \frac{1}{2} (\vec{b} + \vec{c})\).</p>
    <div class="image-row">
                   </div>

     <p>
  <span style="color:#ffbf00; font-weight:bold;">Приклад 7.3.</span>
    Дано куб \(ABCDA_1B_1C_1D_1\) (рис. 7.23). Потрібно виразити вектор \(\overrightarrow{AK}\), де \(K\) – центр грані \(BCC_1B_1\), через вектори \(\overrightarrow{AB} = \vec{a}\), \(\overrightarrow{AC} = \vec{b}\), \(\overrightarrow{AA_1} = \vec{c}\).</p>
    
    <img src="/static/figure7.23.jpg" alt="Куб ABCDA1B1C1D1 із точкою K" style="max-width: 100%; display: block; margin: 20px auto;" loading="lazy">
   <h3>Розв’язання</h3>
    <p>Розглянемо трикутник \(\triangle AKL\), де \(L\) – середина ребра \(BC\), а \(K\) – центр грані \(BCC_1B_1\). За правилом трикутника:</p>
    <p class="math-equation center">\[\overrightarrow{AK} = \overrightarrow{AL} + \overrightarrow{LK}\]</p>
    <p>Знайдемо вектор \(\overrightarrow{AL}\). Оскільки \(L\) – середина ребра \(BC\), вектор \(\overrightarrow{AL}\) є медіаною трикутника \(\triangle ABC\), що виражається через вектори \(\overrightarrow{AB} = \vec{a}\) і \(\overrightarrow{AC} = \vec{b}\). Як було показано в попередньому прикладі (для медіани):</p>
    <p class="math-equation center">\[\overrightarrow{AL} = \frac{\overrightarrow{AB} + \overrightarrow{AC}}{2} = \frac{\vec{a} + \vec{b}}{2}\]</p>
    <p>Знайдемо вектор \(\overrightarrow{LK}\). Точка \(K\) – центр грані \(BCC_1B_1\), а \(L\) – середина ребра \(BC\). У кубі грань \(BCC_1B_1\) перпендикулярна до осі, визначеної вектором \(\overrightarrow{AA_1} = \vec{c}\). Оскільки \(K\) – центр грані, вектор \(\overrightarrow{LK}\) дорівнює половині вектора \(\overrightarrow{AA_1}\), тобто:</p>
    <p class="math-equation center">\[\overrightarrow{LK} = \frac{\overrightarrow{AA_1}}{2} = \frac{\vec{c}}{2}\]</p>
    <p>Підставимо знайдені вектори у вираз для \(\overrightarrow{AK}\):</p>
    <p class="math-equation center">\[\overrightarrow{AK} = \overrightarrow{AL} + \overrightarrow{LK} = \frac{\vec{a} + \vec{b}}{2} + \frac{\vec{c}}{2} = \frac{1}{2} (\vec{a} + \vec{b} + \vec{c})\]</p>
    <p class="example-solution">Відповідь: \(\overrightarrow{AK} = \frac{1}{2} (\vec{a} + \vec{b} + \vec{c})\).</p>
    <div class="image-row">
            </div>
</div>
            </div>
        </div>
    </div>
    <div id="videoModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="videoTitle">
        <div class="modal-header">
            <button class="close-btn" id="closeVideoBtn" aria-label="Закрити">× Закрити</button>
        </div>
        <div class="modal-content">
            <h2 class="glow-title" id="videoTitle">Оберіть відео</h2>
            <div class="video-card-container">
                <div class="video-card" data-video="1">
                    <img src="https://img.icons8.com/?size=100&id=o1CR3NjO7Pv8&format=png&color=000000" alt="Відеокамера" loading="lazy">
                    <h3>Лінійні операції над векторами в просторі</h3>
                </div>
                <div class="video-card" data-video="2">
                    <img src="https://img.icons8.com/?size=100&id=o1CR3NjO7Pv8&format=png&color=000000" alt="Відеокамера" loading="lazy">
                    <h3>Додавання і віднімання векторів</h3>
                </div>
            </div>
        </div>
    </div>
    <div id="videoPlayerModal1" class="modal">
        <div class="modal-header">
            <button class="close-btn" id="closeVideoPlayerBtn1" aria-label="Закрити">× Закрити</button>
        </div>
        <div class="modal-content">
            <div class="video-player-container">
                <iframe id="youtubePlayer1" width="100%" data-src="https://www.youtube.com/embed/Ksy7XZ1xsR8" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            </div>
        </div>
    </div>
    <div id="videoPlayerModal2" class="modal">
        <div class="modal-header">
            <button class="close-btn" id="closeVideoPlayerBtn2" aria-label="Закрити">× Закрити</button>
        </div>
        <div class="modal-content">
            <div class="video-player-container">
                <iframe id="youtubePlayer2" width="100%" data-src="https://www.youtube.com/embed/_4Pfh3N7jWc" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            </div>
        </div>
    </div>
    
    <div id="questionsModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="questionsTitle">
    <div class="modal-header">
        <button class="close-btn" aria-label="Закрити питання" id="closeQuestionsBtn">× Закрити</button>
    </div>
    <div class="modal-content">
        <div class="flashcard-container">
            <div class="flashcard" tabindex="0" role="button" aria-expanded="false">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <p>1. Що таке лінійні операції над векторами?</p>
                    </div>
                    <div class="flashcard-back">
                        <p>Це додавання, віднімання векторів і множення вектора на число.</p>
                    </div>
                </div>
            </div>
            <div class="flashcard" tabindex="0" role="button" aria-expanded="false">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <p>2. Як геометрично виконується додавання двох векторів (правило трикутника)?</p>
                    </div>
                    <div class="flashcard-back">
                        <p>Кінець першого з’єднують із початком другого, тоді вектор із початку першого до кінця другого є їхньою сумою.</p>
                    </div>
                </div>
            </div>
            <div class="flashcard" tabindex="0" role="button" aria-expanded="false">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <p>3. Яке фізичне значення має додавання векторів?</p>
                    </div>
                    <div class="flashcard-back">
                        <p>Воно описує сумарне переміщення тіла після двох послідовних переміщень.</p>
                    </div>
                </div>
            </div>
            <div class="flashcard" tabindex="0" role="button" aria-expanded="false">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <p>4. Як виглядає додавання кількох векторів?</p>
                    </div>
                    <div class="flashcard-back">
                        <p>Вектори з’єднують послідовно «ланцюжком», а сумарний вектор сполучає початок першого з кінцем останнього.</p>
                    </div>
                </div>
            </div>
            <div class="flashcard" tabindex="0" role="button" aria-expanded="false">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <p>5. У чому полягає правило паралелограма для додавання векторів?</p>
                    </div>
                    <div class="flashcard-back">
                        <p>Два вектори відкладають із однієї точки, добудовують паралелограм, а діагональ є їхньою сумою.</p>
                    </div>
                </div>
            </div>
            <div class="flashcard" tabindex="0" role="button" aria-expanded="false">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <p>6. Як додати три некомпланарні вектори (правило паралелепіпеда)?</p>
                    </div>
                    <div class="flashcard-back">
                        <p>Вектори беруть зі спільного початку, будують паралелепіпед, а діагональ від початку до протилежної вершини є їхньою сумою.</p>
                    </div>
                </div>
            </div>
            <div class="flashcard" tabindex="0" role="button" aria-expanded="false">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <p>7. Як визначається різниця векторів \(\vec{a} - \vec{b}\)?</p>
                    </div>
                    <div class="flashcard-back">
                        <p>Це вектор, що з’єднує кінець \(\vec{b}\) із кінцем \(\vec{a}\), якщо вони мають спільний початок.</p>
                    </div>
                </div>
            </div>
            <div class="flashcard" tabindex="0" role="button" aria-expanded="false">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <p>8. Як геометрично знайти різницю векторів за правилом паралелограма?</p>
                    </div>
                    <div class="flashcard-back">
                        <p>Будують протилежний вектор \(-\vec{b}\) і додають його до \(\vec{a}\).</p>
                    </div>
                </div>
            </div>
            <div class="flashcard" tabindex="0" role="button" aria-expanded="false">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <p>9. Що відбувається при множенні вектора на число \(\lambda\)?</p>
                    </div>
                    <div class="flashcard-back">
                        <p>Довжина змінюється у \(|\lambda|\) разів, а напрямок залежить від знака \(\lambda\).</p>
                    </div>
                </div>
            </div>
            <div class="flashcard" tabindex="0" role="button" aria-expanded="false">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <p>10. Яким буде напрямок вектора при \(\lambda > 0\) і при \(\lambda < 0\)?</p>
                    </div>
                    <div class="flashcard-back">
                        <p>При \(\lambda > 0\) він співнапрямлений з початковим, при \(\lambda < 0\) — протилежний.</p>
                    </div>
                </div>
            </div>
            <div class="flashcard" tabindex="0" role="button" aria-expanded="false">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <p>11. Яка головна властивість добутку вектора на число?</p>
                    </div>
                    <div class="flashcard-back">
                        <p>Отриманий вектор завжди колінеарний початковому.</p>
                    </div>
                </div>
            </div>
            <div class="flashcard" tabindex="0" role="button" aria-expanded="false">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <p>12. Які є основні властивості додавання векторів?</p>
</div>
<div class="flashcard-back">
    <ul>
        <li>Комутативність: \(\vec{a} + \vec{b} = \vec{b} + \vec{a}\)</li>
        <li>Асоціативність: \((\vec{a} + \vec{b}) + \vec{c} = \vec{a} + (\vec{b} + \vec{c})\)</li>
        <li>Додавання нульового вектора: \(\vec{a} + \vec{0} = \vec{a}\)</li>
        <li>Сума протилежних векторів: \(\vec{a} + (-\vec{a}) = \vec{0}\)</li>
    </ul>
</div>

                    
                </div>
            </div>
            <div class="flashcard" tabindex="0" role="button" aria-expanded="false">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <p>13. Які є властивості множення вектора на число?</p>
                    </div>
                    <div class="flashcard-back">
                        <p>
                            <ul>
                                <li>Множення на одиницю: \(1 \cdot \vec{a} = \vec{a}\)</li>
                                <li>Асоціативність: \(\lambda (\mu \vec{a}) = \lambda \mu \vec{a}\)</li>
                                <li>Дистрибутивність щодо чисел: \((\lambda + \mu) \cdot \vec{a} = \lambda \vec{a} + \mu \vec{a}\)</li>
                                <li>Дистрибутивність щодо векторів: \(\mu \cdot (\vec{a} + \vec{b}) = \mu \vec{a} + \mu \vec{b}\)</li>
                            </ul>
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
    
<div id="trainerModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="trainerTitle">
        <div class="modal-header">
            <button class="close-btn" aria-label="Закрити тренажер" id="closeTrainerBtn">× Закрити</button>
        </div>
        <div class="modal-content">
            <div class="trainer-container">
                <div class="question-circle"><h3 id="questionNumber">Питання 1</h3></div>
                <div id="questionText"></div>
                <div id="matrixText"></div>
               <div id="canvasWrapper" style="position: relative; display: inline-block;">
  <canvas id="vectorCanvas" width="300" height="300"></canvas>
</div>

                <div class="answer-options">
                    <button class="answer-button" data-answer="0"></button>
                    <button class="answer-button" data-answer="1"></button>
                    <button class="answer-button" data-answer="2"></button>
                    <button class="answer-button" data-answer="3"></button>
                </div>
                <button id="submitAnswerBtn">Перевірити</button>
                <div class="result-message" id="resultMessage"></div>
                <div class="completion-message" id="completionMessage">
                    <div class="completion-emoji"></div>
                    <h2>Тренування завершено!</h2>
                    <p>Молодець!</p>
                    <button id="resetTrainerBtn">Спробувати ще раз</button>
                </div>
            </div>
        </div>
    </div>

 <script>
    document.addEventListener('DOMContentLoaded', function () {
        const elements = {
            openTheoryBtn: document.getElementById('openTheoryBtn'),
            openVideoBtn: document.getElementById('openVideoBtn'),
            openQuestionsBtn: document.getElementById('openQuestionsBtn'),
            openTrainerBtn: document.getElementById('openTrainerBtn'),
            theoryModal: document.getElementById('theoryModal'),
            videoModal: document.getElementById('videoModal'),
            questionsModal: document.getElementById('questionsModal'),
            trainerModal: document.getElementById('trainerModal'),
            closeTheoryBtn: document.getElementById('closeTheoryBtn'),
            closeVideoBtn: document.getElementById('closeVideoBtn'),
            closeQuestionsBtn: document.getElementById('closeQuestionsBtn'),
            closeTrainerBtn: document.getElementById('closeTrainerBtn'),
            closeVideoPlayerBtn1: document.getElementById('closeVideoPlayerBtn1'),
            closeVideoPlayerBtn2: document.getElementById('closeVideoPlayerBtn2'),
            videoPlayerModal1: document.getElementById('videoPlayerModal1'),
            videoPlayerModal2: document.getElementById('videoPlayerModal2'),
            modalOverlay: document.getElementById('modalOverlay'),
            questionText: document.getElementById('questionText'),
            matrixText: document.getElementById('matrixText'),
            submitAnswerBtn: document.getElementById('submitAnswerBtn'),
            resultMessage: document.getElementById('resultMessage'),
            completionMessage: document.getElementById('completionMessage'),
            resetTrainerBtn: document.getElementById('resetTrainerBtn'),
            youtubePlayer1: document.getElementById('youtubePlayer1'),
            youtubePlayer2: document.getElementById('youtubePlayer2'),
            questionCircle: document.querySelector('.question-circle'),
            vectorCanvas: document.getElementById('vectorCanvas'),
            questionNumber: document.getElementById('questionNumber'),
            answerOptions: document.querySelector('.answer-options')
        };

        // Модалі та вкладки
        const tabButtons = elements.theoryModal?.querySelectorAll('.tab-button');
        const tabContents = elements.theoryModal?.querySelectorAll('.tab-content');

        function closeAllTabs() {
            tabButtons?.forEach(btn => {
                btn.classList.remove('active');
                btn.setAttribute('aria-expanded', 'false');
            });
            tabContents?.forEach(content => {
                content.classList.remove('active');
            });
        }

        function toggleTab(tabId, button) {
            const targetContent = elements.theoryModal?.querySelector(`#${tabId}`);
            const isActive = button.classList.contains('active');
            closeAllTabs();
            if (!isActive && targetContent) {
                button.classList.add('active');
                button.setAttribute('aria-expanded', 'true');
                targetContent.classList.add('active');
                if (window.MathJax && MathJax.typesetPromise) {
                    MathJax.typesetPromise([targetContent]).then(() => {
                        const modalContent = elements.theoryModal?.querySelector('.modal-content');
                        if (modalContent) modalContent.scrollTop = 0;
                    }).catch(err => console.error('MathJax rendering failed:', err));
                }
            }
        }

        tabButtons?.forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.getAttribute('data-tab');
                toggleTab(tabId, button);
            });
        });

        closeAllTabs();

        let players = {};
        const playerIds = {
            'youtubePlayer1': 'Ksy7XZ1xsR8',
            'youtubePlayer2': '_4Pfh3N7jWc'
        };
        const playerSrcs = {
            'youtubePlayer1': elements.youtubePlayer1?.getAttribute('data-src'),
            'youtubePlayer2': elements.youtubePlayer2?.getAttribute('data-src')
        };

        function loadYouTubeAPI() {
            if (!window.YT) {
                const tag = document.createElement('script');
                tag.src = "https://www.youtube.com/iframe_api";
                const firstScriptTag = document.getElementsByTagName('script')[0];
                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
            }
        }

        window.onYouTubeIframeAPIReady = function() {
            Object.keys(playerIds).forEach(playerId => {
                const element = elements[playerId];
                if (element) {
                    players[playerId] = new YT.Player(playerId, {
                        videoId: playerIds[playerId],
                        playerVars: { 'autoplay': 0, 'controls': 1, 'rel': 0, 'showinfo': 0 },
                        events: {
                            'onReady': event => {
                                event.target.cueVideoById({ videoId: playerIds[playerId], startSeconds: 0 });
                            }
                        }
                    });
                }
            });
        };

        loadYouTubeAPI();

        function stopAllVideos() {
            Object.keys(players).forEach(playerId => {
                const player = players[playerId];
                const element = elements[playerId];
                if (player && typeof player.stopVideo === 'function') {
                    player.stopVideo();
                }
                if (element) {
                    element.src = '';
                    const parent = element.parentNode;
                    const newIframe = document.createElement('iframe');
                    newIframe.id = playerId;
                    newIframe.setAttribute('data-src', playerSrcs[playerId]);
                    newIframe.setAttribute('frameborder', '0');
                    newIframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture');
                    newIframe.setAttribute('allowfullscreen', '');
                    parent.replaceChild(newIframe, element);
                    elements[playerId] = newIframe;
                    players[playerId] = new YT.Player(playerId, {
                        videoId: playerIds[playerId],
                        playerVars: { 'autoplay': 0, 'controls': 1, 'rel': 0, 'showinfo': 0 },
                        events: {
                            'onReady': event => event.target.cueVideoById({ videoId: playerIds[playerId], startSeconds: 0 })
                        }
                    });
                }
            });
        }

        function openVideoPlayerModal(videoModal, playerId) {
            stopAllVideos();
            toggleModal(elements.videoModal, false);
            toggleModal(videoModal, true);
            const element = elements[playerId];
            if (element && !element.src) {
                element.src = playerSrcs[playerId];
            }
            if (players[playerId] && typeof players[playerId].loadVideoById === 'function') {
                players[playerId].loadVideoById({ videoId: playerIds[playerId], startSeconds: 0 });
            }
        }

        function toggleModal(modal, show) {
            if (!modal) return; // Перевірка на null
            const allModals = [
                elements.theoryModal,
                elements.videoModal,
                elements.questionsModal,
                elements.trainerModal,
                elements.videoPlayerModal1,
                elements.videoPlayerModal2
            ].filter(Boolean);
            allModals.forEach(m => {
                if (m && m !== modal) {
                    m.style.display = 'none';
                }
            });
            modal.style.display = show ? 'flex' : 'none';
            elements.modalOverlay.style.display = show ? 'block' : 'none';
            document.body.style.overflow = show ? 'hidden' : 'auto';
            if (show) {
                const closeBtn = modal.querySelector('.close-btn');
                if (closeBtn) closeBtn.focus();
                if (modal === elements.theoryModal) closeAllTabs();
                if (modal === elements.trainerModal) {
                    currentQuestion = generateCubeQuestion();
                    displayQuestion();
                }
                if (window.MathJax && MathJax.typesetPromise) {
                    MathJax.typesetPromise([modal]).then(() => {
                        const modalContent = modal.querySelector('.modal-content');
                        if (modalContent) modalContent.scrollTop = 0;
                    }).catch(err => console.error('MathJax rendering failed:', err));
                }
            }
        }

        // Додаємо слухачі подій лише для існуючих елементів
        if (elements.openTheoryBtn) elements.openTheoryBtn.addEventListener('click', () => toggleModal(elements.theoryModal, true));
        if (elements.openVideoBtn) elements.openVideoBtn.addEventListener('click', () => toggleModal(elements.videoModal, true));
        if (elements.openQuestionsBtn) elements.openQuestionsBtn.addEventListener('click', () => toggleModal(elements.questionsModal, true));
        if (elements.openTrainerBtn) elements.openTrainerBtn.addEventListener('click', () => toggleModal(elements.trainerModal, true));
        if (elements.closeTheoryBtn) elements.closeTheoryBtn.addEventListener('click', () => toggleModal(elements.theoryModal, false));
        if (elements.closeVideoBtn) elements.closeVideoBtn.addEventListener('click', () => toggleModal(elements.videoModal, false));
        if (elements.closeQuestionsBtn) elements.closeQuestionsBtn.addEventListener('click', () => toggleModal(elements.questionsModal, false));
        if (elements.closeTrainerBtn) elements.closeTrainerBtn.addEventListener('click', () => toggleModal(elements.trainerModal, false));
        if (elements.closeVideoPlayerBtn1) elements.closeVideoPlayerBtn1.addEventListener('click', () => {
            stopAllVideos();
            toggleModal(elements.videoPlayerModal1, false);
            toggleModal(elements.videoModal, true);
        });
        if (elements.closeVideoPlayerBtn2) elements.closeVideoPlayerBtn2.addEventListener('click', () => {
            stopAllVideos();
            toggleModal(elements.videoPlayerModal2, false);
            toggleModal(elements.videoModal, true);
        });
        if (elements.modalOverlay) elements.modalOverlay.addEventListener('click', () => {
            stopAllVideos();
            toggleModal(elements.theoryModal, false);
            toggleModal(elements.videoModal, false);
            toggleModal(elements.questionsModal, false);
            toggleModal(elements.trainerModal, false);
            toggleModal(elements.videoPlayerModal1, false);
            toggleModal(elements.videoPlayerModal2, false);
        });
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
                stopAllVideos();
                toggleModal(elements.theoryModal, false);
                toggleModal(elements.videoModal, false);
                toggleModal(elements.questionsModal, false);
                toggleModal(elements.trainerModal, false);
                toggleModal(elements.videoPlayerModal1, false);
                toggleModal(elements.videoPlayerModal2, false);
            }
        });

        document.querySelectorAll('.flashcard').forEach(card => {
            card.addEventListener('click', () => {
                card.classList.toggle('flipped');
                if (window.MathJax && MathJax.typesetPromise) {
                    MathJax.typesetPromise([card]).catch(err => console.error('MathJax rendering failed:', err));
                }
            });
            card.addEventListener('keydown', e => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    card.classList.toggle('flipped');
                    if (window.MathJax && MathJax.typesetPromise) {
                        MathJax.typesetPromise([card]).catch(err => console.error('MathJax rendering failed:', err));
                    }
                }
            });
        });

        document.querySelectorAll('.video-card').forEach(card => {
            card.addEventListener('click', () => {
                const videoNumber = card.getAttribute('data-video');
                const videoModal = elements[`videoPlayerModal${videoNumber}`];
                const playerId = `youtubePlayer${videoNumber}`;
                if (videoModal && playerId) openVideoPlayerModal(videoModal, playerId);
            });
        });

// Код тренажера
let currentQuestionType = 1;
let currentQuestion = null;
let selectedAnswer = null;
let vectorA = null, vectorB = null;
let userVectorC = { start: null, end: null };
let lastDrawTime = 0;

// Перевірка, чи всі елементи знайдено
Object.keys(elements).forEach(key => {
    if (!elements[key]) console.error(`Element ${key} not found in DOM`);
});

function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function generateCubeQuestion() {
    const vertices = {
        A: [0, 0, 0], B: [1, 0, 0], C: [1, 1, 0], D: [0, 1, 0],
        A1: [0, 0, 1], B1: [1, 0, 1], C1: [1, 1, 1], D1: [0, 1, 1]
    };

    const vectorGroups = [
        [
            { name: '\\overrightarrow{AB}', start: 'A', end: 'B' }, // (1, 0, 0)
            { name: '\\overrightarrow{A_1B_1}', start: 'A1', end: 'B1' }, // (1, 0, 0)
            { name: '\\overrightarrow{CD}', start: 'C', end: 'D' }, // (-1, 0, 0)
            { name: '\\overrightarrow{C_1D_1}', start: 'C1', end: 'D1' } // (-1, 0, 0)
        ],
        [
            { name: '\\overrightarrow{BC}', start: 'B', end: 'C' }, // (0, 1, 0)
            { name: '\\overrightarrow{DA}', start: 'D', end: 'A' }, // (0, -1, 0)
            { name: '\\overrightarrow{B_1C_1}', start: 'B1', end: 'C1' }, // (0, 1, 0)
            { name: '\\overrightarrow{D_1A_1}', start: 'D1', end: 'A1' } // (0, -1, 0)
        ],
        [
            { name: '\\overrightarrow{AA_1}', start: 'A', end: 'A1' }, // (0, 0, 1)
            { name: '\\overrightarrow{BB_1}', start: 'B', end: 'B1' }, // (0, 0, 1)
            { name: '\\overrightarrow{CC_1}', start: 'C', end: 'C1' }, // (0, 0, 1)
            { name: '\\overrightarrow{DD_1}', start: 'D', end: 'D1' } // (0, 0, 1)
        ],
        [
            { name: '\\overrightarrow{AC}', start: 'A', end: 'C' }, // (1, 1, 0)
            { name: '\\overrightarrow{BD}', start: 'B', end: 'D' }, // (-1, 1, 0)
            { name: '\\overrightarrow{B_1D_1}', start: 'B1', end: 'D1' } // (-1, 1, 0)
        ]
    ];

    // Вибираємо одну групу для колінеарних векторів
    const collinearGroup = vectorGroups[getRandomInt(0, 3)];
    const collinearIndices = shuffle([...Array(collinearGroup.length).keys()]).slice(0, 2);
    const collinearVectors = collinearIndices.map(i => collinearGroup[i]);
    const collinearPair = [collinearVectors[0].name, collinearVectors[1].name];

    // Перевірка колінеарності
    const start1 = vertices[collinearVectors[0].start];
    const end1 = vertices[collinearVectors[0].end];
    const start2 = vertices[collinearVectors[1].start];
    const end2 = vertices[collinearVectors[1].end];
    const vec1 = [end1[0] - start1[0], end1[1] - start1[1], end1[2] - start1[2]];
    const vec2 = [end2[0] - start2[0], end2[1] - start2[1], end2[2] - start2[2]];
    const isCollinear = (vec1[0] * vec2[1] === vec2[0] * vec1[1] && vec1[0] * vec2[2] === vec2[0] * vec1[2] && vec1[1] * vec2[2] === vec2[1] * vec1[2] && (vec1[0] !== 0 || vec1[1] !== 0 || vec1[2] !== 0));

    if (!isCollinear) {
        console.error('Generated non-collinear pair:', collinearPair, vec1, vec2);
        return generateCubeQuestion(); // Повторна генерація, якщо пара не колінеарна
    }

    // Початковий набір векторів - включаємо колінеарну пару
    let vectors = [...collinearVectors];
    const usedVectorNames = new Set(collinearVectors.map(v => v.name));
    
    // Додаємо ще 2 вектори з інших груп
    while (vectors.length < 4) {
        const groupIndex = getRandomInt(0, vectorGroups.length - 1);
        if (groupIndex !== vectorGroups.indexOf(collinearGroup)) {
            const vec = vectorGroups[groupIndex][getRandomInt(0, vectorGroups[groupIndex].length - 1)];
            if (!usedVectorNames.has(vec.name)) {
                vectors.push(vec);
                usedVectorNames.add(vec.name);
            }
        }
    }
    vectors = shuffle(vectors);

    // Генеруємо відповіді
    const answerPairs = [];
    const usedPairs = new Set();
    
    // Додаємо правильну пару
    const correctPairStr = `${collinearPair[0]}|${collinearPair[1]}`;
    answerPairs.push(collinearPair);
    usedPairs.add(correctPairStr);
    
    // Додаємо 3 неправильні пари
    while (answerPairs.length < 4) {
        const v1 = vectors[getRandomInt(0, vectors.length - 1)];
        const v2 = vectors[getRandomInt(0, vectors.length - 1)];
        if (v1.name !== v2.name) {
            const pairStr = `${v1.name}|${v2.name}`;
            const reversePairStr = `${v2.name}|${v1.name}`;
            if (!usedPairs.has(pairStr) && !usedPairs.has(reversePairStr)) {
                // Перевірка, що пара не є колінеарною
                const start1 = vertices[v1.start];
                const end1 = vertices[v1.end];
                const start2 = vertices[v2.start];
                const end2 = vertices[v2.end];
                const vec1 = [end1[0] - start1[0], end1[1] - start1[1], end1[2] - start1[2]];
                const vec2 = [end2[0] - start2[0], end2[1] - start2[1], end2[2] - start2[2]];
                const isNonCollinear = !(vec1[0] * vec2[1] === vec2[0] * vec1[1] && vec1[0] * vec2[2] === vec2[0] * vec1[2] && vec1[1] * vec2[2] === vec2[1] * vec1[2] && (vec1[0] !== 0 || vec1[1] !== 0 || vec1[2] !== 0));
                if (isNonCollinear) {
                    answerPairs.push([v1.name, v2.name]);
                    usedPairs.add(pairStr);
                }
            }
        }
    }
    
    const correctAnswer = `(${collinearPair[0]}, ${collinearPair[1]})`;
    const answers = shuffle([...answerPairs.map(pair => `(${pair[0]}, ${pair[1]})`)]);
    const correctIndex = answers.findIndex(answer => answer === correctAnswer);

    console.log('Generated cube question:', {
        collinearPair,
        answers,
        correctIndex,
        vectors: vectors.map(v => ({ name: v.name, start: v.start, end: v.end }))
    });

    const canvas = document.createElement('canvas');
    canvas.width = 300;
    canvas.height = 300;
    const ctx = canvas.getContext('2d');

    const project = (point) => {
        const scale = 100;
        const xOffset = 75;
        const yOffset = 200;
        const x = point[0] * scale + point[2] * scale * 0.5 + xOffset;
        const y = -point[1] * scale - point[2] * scale * 0.5 + yOffset;
        return [x, y];
    };

    // Малюємо куб
    ctx.beginPath();
    const edges = [
        ['A', 'B'], ['B', 'C'], ['C', 'D'], ['D', 'A'],
        ['A1', 'B1'], ['B1', 'C1'], ['C1', 'D1'], ['D1', 'A1'],
        ['A', 'A1'], ['B', 'B1'], ['C', 'C1'], ['D', 'D1']
    ];
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1.5;
    edges.forEach(([start, end]) => {
        const [x1, y1] = project(vertices[start]);
        const [x2, y2] = project(vertices[end]);
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
    });
    ctx.stroke();

    // Підписи вершин
    ctx.fillStyle = 'yellow';
    ctx.font = 'bold 14px Arial';
    ['A', 'B', 'C', 'D', 'A1', 'B1', 'C1', 'D1'].forEach(v => {
        const [x, y] = project(vertices[v]);
        if (v === 'A') ctx.fillText(v, x - 10, y + 20);
        else if (v === 'B') ctx.fillText(v, x, y + 20);
        else if (v === 'C') ctx.fillText(v, x + 10, y);
        else if (v === 'D') ctx.fillText(v, x - 15, y);
        else if (v === 'C1') ctx.fillText(v, x + 10, y);
        else if (v === 'D1') ctx.fillText(v, x - 20, y - 5);
        else ctx.fillText(v, x + 5, y - 5);
    });

    // Малюємо вектори червоним
    vectors.forEach(v => {
        ctx.beginPath();
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        const [x1, y1] = project(vertices[v.start]);
        const [x2, y2] = project(vertices[v.end]);
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        const angle = Math.atan2(y2 - y1, x2 - x1);
        ctx.lineTo(x2 - 10 * Math.cos(angle - Math.PI / 6), y2 - 10 * Math.sin(angle - Math.PI / 6));
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - 10 * Math.cos(angle + Math.PI / 6), y2 - 10 * Math.sin(angle + Math.PI / 6));
        ctx.stroke();
    });

    return {
        question: 'У кубі \\(ABCDA_{1}B_{1}C_{1}D_{1}\\) зображено вектори. Яка пара векторів є колінеарною?',
        canvas: canvas.toDataURL(),
        answers: answers,
        correct: correctIndex,
        vectors: vectors
    };
}

           function isValidVectorPair(vecA, vecB) {
    // vecA і vecB — це масиви [dx, dy]
    const dotProduct = vecA[0] * vecB[0] + vecA[1] * vecB[1];
    const normA = Math.sqrt(vecA[0] ** 2 + vecA[1] ** 2);
    const normB = Math.sqrt(vecB[0] ** 2 + vecB[1] ** 2);
    
    // Перевірка на ненульові вектори
    if (normA === 0 || normB === 0) return false;
    
    // Обчислюємо косинус кута
    const cosTheta = dotProduct / (normA * normB);
    
    // Перевірка неколінеарності (|cosTheta| < 0.999)
    const isNonCollinear = Math.abs(cosTheta) < 0.999;
    
    // Перевірка діапазону кутів: 30° ≤ |θ| ≤ 150° → |cos(θ)| ≤ √3/2 ≈ 0.866
    const isValidAngle = Math.abs(cosTheta) <= Math.sqrt(3) / 2;
    
    // Логування кута для діагностики
    const angle = Math.acos(Math.min(Math.max(cosTheta, -1), 1)) * 180 / Math.PI;
    console.log('Angle between vectors:', angle.toFixed(2), 'degrees');
    
    return isNonCollinear && isValidAngle;
}
            
function generateVectorQuestion() {
    let tempVectorA, tempVectorB;
    let a_dx, a_dy, b_dx, b_dy;
    let isValid = false;
    let attempts = 0;
    const maxAttempts = 100; // Захист від нескінченного циклу

    // Генеруємо вектори, доки не виконаються всі умови
    while (!isValid && attempts < maxAttempts) {
        tempVectorA = {
            start: { x: getRandomInt(2, 7), y: getRandomInt(2, 7) },
            end: { x: getRandomInt(2, 7), y: getRandomInt(2, 7) }
        };
        tempVectorB = {
            start: { x: tempVectorA.end.x, y: tempVectorA.end.y },
            end: { x: getRandomInt(2, 7), y: getRandomInt(2, 7) }
        };
        
        a_dx = tempVectorA.end.x - tempVectorA.start.x;
        a_dy = tempVectorA.end.y - tempVectorA.start.y;
        b_dx = tempVectorB.end.x - tempVectorB.start.x;
        b_dy = tempVectorB.end.y - tempVectorB.start.y;
        
        // Перевірка існуючих умов
        const isValidExisting = !(
            (a_dx === 0 && a_dy === 0) || // Нульовий вектор a
            (b_dx === 0 && b_dy === 0) || // Нульовий вектор b
            Math.sqrt(a_dx * a_dx + a_dy * a_dy) < 2 || // Короткий вектор a
            Math.sqrt(b_dx * b_dx + b_dy * b_dy) < 2 || // Короткий вектор b
            Math.abs(a_dx) > 4 || Math.abs(a_dy) > 4 || // Великі компоненти a
            Math.abs(b_dx) > 4 || Math.abs(b_dy) > 4   // Великі компоненти b
        );
        
        // Перевірка неколінеарності та кута
        const isValidAngle = isValidVectorPair([a_dx, a_dy], [b_dx, b_dy]);
        
        isValid = isValidExisting && isValidAngle;
        attempts++;
    }
    
    // Якщо не вдалося згенерувати за maxAttempts, використовуємо фіксований приклад
    if (!isValid) {
        console.warn(`Could not generate valid vector pair after ${maxAttempts} attempts, using fallback vectors`);
        tempVectorA = {
            start: { x: 2, y: 2 },
            end: { x: 4, y: 2 } // \(\vec{a} = (2, 0)\)
        };
        tempVectorB = {
            start: { x: 4, y: 2 },
            end: { x: 4, y: 4 } // \(\vec{b} = (0, 2)\)
        };
        // Перевірка: кут між (2, 0) і (0, 2) = 90°
        a_dx = tempVectorA.end.x - tempVectorA.start.x;
        a_dy = tempVectorA.end.y - tempVectorA.start.y;
        b_dx = tempVectorB.end.x - tempVectorB.start.x;
        b_dy = tempVectorB.end.y - tempVectorB.start.y;
    }
    
    userVectorC = { start: null, end: null };
    vectorA = tempVectorA; // Оновлюємо глобальну змінну
    vectorB = tempVectorB; // Оновлюємо глобальну змінну
    
    console.log(`Generated vectors: a from (${tempVectorA.start.x}, ${tempVectorA.start.y}) to (${tempVectorA.end.x}, ${tempVectorA.end.y}), b from (${tempVectorB.start.x}, ${tempVectorB.start.y}) to (${tempVectorB.end.x}, ${tempVectorB.end.y})`);
    
    return {
        question: 'На сітці зображено вектори \\(\\vec{a}\\) і \\(\\vec{b}\\), з\'єднані так, що початок \\(\\vec{b}\\) збігається з кінцем \\(\\vec{a}\\). Побудуйте вектор \\(\\vec{c}\\), що є їхньою сумою \\(\\vec{c} = \\vec{a} + \\vec{b}\\). ',
        vectorA: tempVectorA,
        vectorB: tempVectorB
    };
}

function generateVectorDifferenceQuestion() {
    let tempVectorA, tempVectorB;
    let a_dx, a_dy, b_dx, b_dy;
    let isValid = false;
    let attempts = 0;
    const maxAttempts = 100;

    while (!isValid && attempts < maxAttempts) {
        tempVectorA = {
            start: { x: getRandomInt(2, 7), y: getRandomInt(2, 7) },
            end: { x: getRandomInt(2, 7), y: getRandomInt(2, 7) }
        };
        tempVectorB = {
            start: { x: tempVectorA.start.x, y: tempVectorA.start.y },
            end: { x: getRandomInt(2, 7), y: getRandomInt(2, 7) }
        };

        a_dx = tempVectorA.end.x - tempVectorA.start.x;
        a_dy = tempVectorA.end.y - tempVectorA.start.y;
        b_dx = tempVectorB.end.x - tempVectorB.start.x;
        b_dy = tempVectorB.end.y - tempVectorB.start.y;

        const isValidExisting = !(
            (a_dx === 0 && a_dy === 0) ||
            (b_dx === 0 && b_dy === 0) ||
            Math.sqrt(a_dx * a_dx + a_dy * a_dy) < 2 ||
            Math.sqrt(b_dx * b_dx + b_dy * b_dy) < 2 ||
            Math.abs(a_dx) > 4 || Math.abs(a_dy) > 4 ||
            Math.abs(b_dx) > 4 || Math.abs(b_dy) > 4 ||
            (a_dx === b_dx && a_dy === b_dy)
        );

        const isValidAngle = isValidVectorPair([a_dx, a_dy], [b_dx, b_dy]);
        
        isValid = isValidExisting && isValidAngle;
        attempts++;
    }

    if (!isValid) {
        console.warn(`Could not generate valid vector pair after ${maxAttempts} attempts, using fallback vectors`);
        tempVectorA = {
            start: { x: 2, y: 2 },
            end: { x: 4, y: 2 } // \(\vec{a} = (2, 0)\)
        };
        tempVectorB = {
            start: { x: 2, y: 2 },
            end: { x: 2, y: 4 } // \(\vec{b} = (0, 2)\)
        };
        a_dx = tempVectorA.end.x - tempVectorA.start.x;
        a_dy = tempVectorA.end.y - tempVectorA.start.y;
        b_dx = tempVectorB.end.x - tempVectorB.start.x;
        b_dy = tempVectorB.end.y - tempVectorB.start.y;
    }

    userVectorC = { start: null, end: null };
    vectorA = tempVectorA;
    vectorB = tempVectorB;

    console.log(`Generated vectors for difference: a from (${tempVectorA.start.x}, ${tempVectorA.start.y}) to (${tempVectorA.end.x}, ${tempVectorA.end.y}), b from (${tempVectorB.start.x}, ${tempVectorB.start.y}) to (${tempVectorB.end.x}, ${tempVectorB.end.y})`);

    return {
        question: 'На сітці зображено вектори \\(\\vec{a}\\) і \\(\\vec{b}\\), з\'єднані так, що їх початки збігаються. Побудуйте вектор \\(\\vec{c}\\), що є їхньою різницею \\(\\vec{c} = \\vec{a} - \\vec{b}\\). ',
        vectorA: tempVectorA,
        vectorB: tempVectorB
    };
}
            
function generateVectorParallelogramQuestion() {
    let tempVectorA, tempVectorB;
    let a_dx, a_dy, b_dx, b_dy;
    let isValid = false;
    let attempts = 0;
    const maxAttempts = 100;

    while (!isValid && attempts < maxAttempts) {
        tempVectorA = {
            start: { x: getRandomInt(2, 7), y: getRandomInt(2, 7) },
            end: { x: getRandomInt(2, 7), y: getRandomInt(2, 7) }
        };
        tempVectorB = {
            start: { x: tempVectorA.start.x, y: tempVectorA.start.y },
            end: { x: getRandomInt(2, 7), y: getRandomInt(2, 7) }
        };

        a_dx = tempVectorA.end.x - tempVectorA.start.x;
        a_dy = tempVectorA.end.y - tempVectorA.start.y;
        b_dx = tempVectorB.end.x - tempVectorB.start.x;
        b_dy = tempVectorB.end.y - tempVectorB.start.y;

        const isValidExisting = !(
            (a_dx === 0 && a_dy === 0) ||
            (b_dx === 0 && b_dy === 0) ||
            Math.sqrt(a_dx * a_dx + a_dy * a_dy) < 2 ||
            Math.sqrt(b_dx * b_dx + b_dy * b_dy) < 2 ||
            Math.abs(a_dx) > 4 || Math.abs(a_dy) > 4 ||
            Math.abs(b_dx) > 4 || Math.abs(b_dy) > 4 ||
            (a_dx === b_dx && a_dy === b_dy)
        );

        const isValidAngle = isValidVectorPair([a_dx, a_dy], [b_dx, b_dy]);
        
        isValid = isValidExisting && isValidAngle;
        attempts++;
    }

    if (!isValid) {
        console.warn(`Could not generate valid vector pair after ${maxAttempts} attempts, using fallback vectors`);
        tempVectorA = {
            start: { x: 2, y: 2 },
            end: { x: 4, y: 2 } // \(\vec{a} = (2, 0)\)
        };
        tempVectorB = {
            start: { x: 2, y: 2 },
            end: { x: 2, y: 4 } // \(\vec{b} = (0, 2)\)
        };
        a_dx = tempVectorA.end.x - tempVectorA.start.x;
        a_dy = tempVectorA.end.y - tempVectorA.start.y;
        b_dx = tempVectorB.end.x - tempVectorB.start.x;
        b_dy = tempVectorB.end.y - tempVectorB.start.y;
    }

    userVectorC = { start: null, end: null };
    vectorA = tempVectorA;
    vectorB = tempVectorB;

    console.log(`Generated vectors for parallelogram: a from (${tempVectorA.start.x}, ${tempVectorA.start.y}) to (${tempVectorA.end.x}, ${tempVectorA.end.y}), b from (${tempVectorB.start.x}, ${tempVectorB.start.y}) to (${tempVectorB.end.x}, ${tempVectorB.end.y})`);

    return {
        question: 'На сітці зображено вектори \\(\\vec{a}\\) і \\(\\vec{b}\\), що мають спільний початок. Побудуйте вектор \\(\\vec{c}\\), що є їхньою сумою \\(\\vec{c} = \\vec{a} + \\vec{b}\\) за правилом паралелограма.',
        vectorA: tempVectorA,
        vectorB: tempVectorB
    };
}
          function generateCubeVectorSumQuestion(groupIndex = null) {
    const vertices = {
        A: [0, 0, 0], B: [1, 0, 0], C: [1, 1, 0], D: [0, 1, 0],
        A1: [0, 0, 1], B1: [1, 0, 1], C1: [1, 1, 1], D1: [0, 1, 1]
    };

    const vectorGroups = [
        { vectors: [{ name: '\\overrightarrow{AA_1}', start: 'A', end: 'A1' }, { name: '\\overrightarrow{AB}', start: 'A', end: 'B' }, { name: '\\overrightarrow{AD}', start: 'A', end: 'D' }], result: { name: '\\overrightarrow{AC_1}', start: 'A', end: 'C1' } },
        { vectors: [{ name: '\\overrightarrow{DA}', start: 'D', end: 'A' }, { name: '\\overrightarrow{DD_1}', start: 'D', end: 'D1' }, { name: '\\overrightarrow{DC}', start: 'D', end: 'C' }], result: { name: '\\overrightarrow{DB_1}', start: 'D', end: 'B1' } },
        { vectors: [{ name: '\\overrightarrow{CD}', start: 'C', end: 'D' }, { name: '\\overrightarrow{CB}', start: 'C', end: 'B' }, { name: '\\overrightarrow{CC_1}', start: 'C', end: 'C1' }], result: { name: '\\overrightarrow{CA_1}', start: 'C', end: 'A1' } },
        { vectors: [{ name: '\\overrightarrow{BA}', start: 'B', end: 'A' }, { name: '\\overrightarrow{BC}', start: 'B', end: 'C' }, { name: '\\overrightarrow{BB_1}', start: 'B', end: 'B1' }], result: { name: '\\overrightarrow{BD_1}', start: 'B', end: 'D1' } },
        { vectors: [{ name: '\\overrightarrow{A_1A}', start: 'A1', end: 'A' }, { name: '\\overrightarrow{A_1B_1}', start: 'A1', end: 'B1' }, { name: '\\overrightarrow{A_1D_1}', start: 'A1', end: 'D1' }], result: { name: '\\overrightarrow{A_1C}', start: 'A1', end: 'C' } },
        { vectors: [{ name: '\\overrightarrow{D_1A_1}', start: 'D1', end: 'A1' }, { name: '\\overrightarrow{D_1D}', start: 'D1', end: 'D' }, { name: '\\overrightarrow{D_1C_1}', start: 'D1', end: 'C1' }], result: { name: '\\overrightarrow{D_1B}', start: 'D1', end: 'B' } },
        { vectors: [{ name: '\\overrightarrow{C_1D_1}', start: 'C1', end: 'D1' }, { name: '\\overrightarrow{C_1B_1}', start: 'C1', end: 'B1' }, { name: '\\overrightarrow{C_1C}', start: 'C1', end: 'C' }], result: { name: '\\overrightarrow{C_1A}', start: 'C1', end: 'A' } },
        { vectors: [{ name: '\\overrightarrow{B_1A_1}', start: 'B1', end: 'A1' }, { name: '\\overrightarrow{B_1C_1}', start: 'B1', end: 'C1' }, { name: '\\overrightarrow{B_1B}', start: 'B1', end: 'B' }], result: { name: '\\overrightarrow{B_1D}', start: 'B1', end: 'D' } }
    ];

    let selectedGroupIndex = groupIndex !== null ? groupIndex : getRandomInt(0, vectorGroups.length - 1);
    const selectedGroup = vectorGroups[selectedGroupIndex];

    // Перевірка унікальності векторів
    const vectorNames = selectedGroup.vectors.map(v => v.name);
    const uniqueVectorNames = new Set(vectorNames);
    if (uniqueVectorNames.size !== vectorNames.length) {
        console.error('Duplicate vectors detected in group:', vectorNames);
        selectedGroupIndex = (selectedGroupIndex + 1) % vectorGroups.length;
        return generateCubeVectorSumQuestion(selectedGroupIndex);
    }

    userVectorC = { start: null, end: null };

    const canvas = document.createElement('canvas');
    canvas.width = 300;
    canvas.height = 350;
    const ctx = canvas.getContext('2d');

    const project = (point) => {
        const scale = 100;
        const xOffset = 75;
        const yOffset = 200;
        const x = point[0] * scale + point[2] * scale * 0.5 + xOffset;
        const y = -point[1] * scale - point[2] * scale * 0.5 + yOffset;
        return [x, y];
    };

    // Малюємо куб
    ctx.beginPath();
    const edges = [
        ['A', 'B'], ['B', 'C'], ['C', 'D'], ['D', 'A'],
        ['A1', 'B1'], ['B1', 'C1'], ['C1', 'D1'], ['D1', 'A1'],
        ['A', 'A1'], ['B', 'B1'], ['C', 'C1'], ['D', 'D1']
    ];
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1.5;
    edges.forEach(([start, end]) => {
        const [x1, y1] = project(vertices[start]);
        const [x2, y2] = project(vertices[end]);
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
    });
    ctx.stroke();

    // Підписи вершин
    ctx.fillStyle = 'black';
    ctx.font = 'bold 14px Arial';
    ['A', 'B', 'C', 'D', 'A1', 'B1', 'C1', 'D1'].forEach(v => {
        const [x, y] = project(vertices[v]);
        if (v === 'A') ctx.fillText(v, x - 10, y + 20);
        else if (v === 'B') ctx.fillText(v, x, y + 20);
        else if (v === 'C') ctx.fillText(v, x + 10, y);
        else if (v === 'D') ctx.fillText(v, x - 15, y);
        else if (v === 'C1') ctx.fillText(v, x + 10, y);
        else if (v === 'D1') ctx.fillText(v, x - 20, y - 5);
        else ctx.fillText(v, x + 5, y - 5);
    });

    // Малюємо три вектори червоним
    selectedGroup.vectors.forEach(v => {
        ctx.beginPath();
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        const [x1, y1] = project(vertices[v.start]);
        const [x2, y2] = project(vertices[v.end]);
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        const angle = Math.atan2(y2 - y1, x2 - x1);
        ctx.lineTo(x2 - 10 * Math.cos(angle - Math.PI / 6), y2 - 10 * Math.sin(angle - Math.PI / 6));
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - 10 * Math.cos(angle + Math.PI / 6), y2 - 10 * Math.sin(angle + Math.PI / 6));
        ctx.stroke();

        // Додаємо підписи до векторів
        const midX = (x1 + x2) / 2;
        const midY = (y1 + y2) / 2;
        const dx = x2 - x1;
        const dy = y2 - y1;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const offset = 20;
        const offsetX = -dy / len * offset;
        const offsetY = dx / len * offset;

        ctx.fillStyle = 'red';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(v.name.replace(/\\overrightarrow\{([A-Za-z1-9_]+)\}/, '$1'), midX + offsetX, midY + offsetY);
    });

    console.log('Generated cube vector sum question:', {
        groupIndex: selectedGroupIndex,
        vectors: selectedGroup.vectors.map(v => v.name),
        result: selectedGroup.result.name
    });

    // Формуємо текст питання з явним позначенням векторів як математичних виразів
    const vectorList = selectedGroup.vectors.map(v => `\\(${v.name}\\)`).join(', ');
    return {
        question: `У кубі \\(ABCDA_{1}B_{1}C_{1}D_{1}\\) зображено вектори ${vectorList}. Побудуйте вектор \\(\\vec{c}\\), що є їхньою сумою.`,
        canvas: canvas.toDataURL(),
        vectors: selectedGroup.vectors,
        correct: selectedGroup.result,
        groupIndex: selectedGroupIndex
    };
}
function generateVectorMultipleQuestion() {
    // Фіксовані приклади
    const examples = [
        // Приклад 1: Відповідь -2\vec{a} = \vec{c}
        {
            vectorA: {
                start: { x: 3, y: 2 },
                end: { x: 5, y: 2 } // \vec{a} = (2, 0)
            },
            vectors: [
                {
                    name: '\\overrightarrow{b}',
                    multiplier: 0.5,
                    color: 'green',
                    vector: {
                        start: { x: 6, y: 4 },
                        end: { x: 7, y: 4 } // 0.5\vec{a} = (1, 0)
                    }
                },
                {
                    name: '\\overrightarrow{c}',
                    multiplier: -2,
                    color: 'blue',
                    vector: {
                        start: { x: 5, y: 6 },
                        end: { x: 1, y: 6 } // -2\vec{a} = (-4, 0)
                    }
                },
                {
                    name: '\\overrightarrow{d}',
                    multiplier: 2,
                    color: 'purple',
                    vector: {
                        start: { x: 2, y: 8 },
                        end: { x: 6, y: 8 } // 2\vec{a} = (4, 0)
                    }
                },
                {
                    name: '\\overrightarrow{f}',
                    multiplier: -0.5,
                    color: 'orange',
                    vector: {
                        start: { x: 2, y: 9 },
                        end: { x: 1, y: 9 } // -0.5\vec{a} = (-1, 0)
                    }
                }
            ],
            multiplier: -2, // Відповідь: \vec{c}
            correctVectorName: '\\overrightarrow{c}' // Назва правильного вектора
        },
        // Приклад 2: Відповідь -\vec{a}
        {
            vectorA: {
                start: { x: 3, y: 2 },
                end: { x: 5, y: 4 } // \vec{a} = (2, 2)
            },
            vectors: [
                {
                    name: '\\overrightarrow{b}',
                    multiplier: 0.5,
                    color: 'green',
                    vector: {
                        start: { x: 6, y: 4 },
                        end: { x: 7, y: 5 } // 0.5\vec{a} = (1, 1)
                    }
                },
                {
                    name: '\\overrightarrow{c}',
                    multiplier: -1,
                    color: 'blue',
                    vector: {
                        start: { x: 5, y: 6 },
                        end: { x: 3, y: 4 } // -\vec{a} = (-2, -2)
                    }
                },
                {
                    name: '\\overrightarrow{d}',
                    multiplier: 2,
                    color: 'purple',
                    vector: {
                        start: { x: 2, y: 8 },
                        end: { x: 6, y: 12 } // 2\vec{a} = (4, 4)
                    }
                },
                {
                    name: '\\overrightarrow{f}',
                    multiplier: -0.5,
                    color: 'orange',
                    vector: {
                        start: { x: 2, y: 9 },
                        end: { x: 1, y: 8 } // -0.5\vec{a} = (-1, -1)
                    }
                }
            ],
            multiplier: -1, // Відповідь: \vec{c}
            correctVectorName: '\\overrightarrow{c}'
        },
        // Приклад 3: Відповідь 0.5\vec{a} = \vec{b}
        {
            vectorA: {
                start: { x: 3, y: 2 },
                end: { x: 5, y: 2 } // \vec{a} = (2, 0)
            },
            vectors: [
                {
                    name: '\\overrightarrow{b}',
                    multiplier: 0.5,
                    color: 'green',
                    vector: {
                        start: { x: 6, y: 4 },
                        end: { x: 7, y: 4 } // 0.5\vec{a} = (1, 0)
                    }
                },
                {
                    name: '\\overrightarrow{c}',
                    multiplier: -2,
                    color: 'blue',
                    vector: {
                        start: { x: 5, y: 6 },
                        end: { x: 1, y: 6 } // -2\vec{a} = (-4, 0)
                    }
                },
                {
                    name: '\\overrightarrow{d}',
                    multiplier: 1.5,
                    color: 'purple',
                    vector: {
                        start: { x: 2, y: 8 },
                        end: { x: 5, y: 8 } // 1.5\vec{a} = (3, 0)
                    }
                },
                {
                    name: '\\overrightarrow{f}',
                    multiplier: -0.5,
                    color: 'orange',
                    vector: {
                        start: { x: 2, y: 9 },
                        end: { x: 1, y: 9 } // -0.5\vec{a} = (-1, 0)
                    }
                }
            ],
            multiplier: 0.5, // Відповідь: \vec{b}
            correctVectorName: '\\overrightarrow{b}'
        },
        // Приклад 4: Відповідь -0.5\vec{a} = \vec{f}
        {
            vectorA: {
                start: { x: 3, y: 2 },
                end: { x: 5, y: 2 } // \vec{a} = (2, 0)
            },
            vectors: [
                {
                    name: '\\overrightarrow{b}',
                    multiplier: 0.5,
                    color: 'green',
                    vector: {
                        start: { x: 6, y: 4 },
                        end: { x: 7, y: 4 } // 0.5\vec{a} = (1, 0)
                    }
                },
                {
                    name: '\\overrightarrow{c}',
                    multiplier: -2,
                    color: 'blue',
                    vector: {
                        start: { x: 5, y: 6 },
                        end: { x: 1, y: 6 } // -2\vec{a} = (-4, 0)
                    }
                },
                {
                    name: '\\overrightarrow{d}',
                    multiplier: 1.5,
                    color: 'purple',
                    vector: {
                        start: { x: 2, y: 8 },
                        end: { x: 5, y: 8 } // 1.5\vec{a} = (3, 0)
                    }
                },
                {
                    name: '\\overrightarrow{f}',
                    multiplier: -0.5,
                    color: 'orange',
                    vector: {
                        start: { x: 2, y: 9 },
                        end: { x: 1, y: 9 } // -0.5\vec{a} = (-1, 0)
                    }
                }
            ],
            multiplier: -0.5, // Відповідь: \vec{f}
            correctVectorName: '\\overrightarrow{f}'
        },
        // Приклад 5: Відповідь 2\vec{a} = \vec{d}
        {
            vectorA: {
                start: { x: 3, y: 2 },
                end: { x: 5, y: 2 } // \vec{a} = (2, 0)
            },
            vectors: [
                {
                    name: '\\overrightarrow{b}',
                    multiplier: 0.5,
                    color: 'green',
                    vector: {
                        start: { x: 6, y: 4 },
                        end: { x: 7, y: 4 } // 0.5\vec{a} = (1, 0)
                    }
                },
                {
                    name: '\\overrightarrow{c}',
                    multiplier: -2,
                    color: 'blue',
                    vector: {
                        start: { x: 5, y: 6 },
                        end: { x: 1, y: 6 } // -2\vec{a} = (-4, 0)
                    }
                },
                {
                    name: '\\overrightarrow{d}',
                    multiplier: 2,
                    color: 'purple',
                    vector: {
                        start: { x: 2, y: 8 },
                        end: { x: 6, y: 8 } // 2\vec{a} = (4, 0)
                    }
                },
                {
                    name: '\\overrightarrow{f}',
                    multiplier: -0.5,
                    color: 'orange',
                    vector: {
                        start: { x: 2, y: 9 },
                        end: { x: 1, y: 9 } // -0.5\vec{a} = (-1, 0)
                    }
                }
            ],
            multiplier: 2, // Відповідь: \vec{d}
            correctVectorName: '\\overrightarrow{d}'
        },
        // Приклад 6: Відповідь 1.5\vec{a} = \vec{d}
        {
            vectorA: {
                start: { x: 3, y: 2 },
                end: { x: 5, y: 2 } // \vec{a} = (2, 0)
            },
            vectors: [
                {
                    name: '\\overrightarrow{b}',
                    multiplier: 0.5,
                    color: 'green',
                    vector: {
                        start: { x: 6, y: 4 },
                        end: { x: 7, y: 4 } // 0.5\vec{a} = (1, 0)
                    }
                },
                {
                    name: '\\overrightarrow{c}',
                    multiplier: -2,
                    color: 'blue',
                    vector: {
                        start: { x: 5, y: 6 },
                        end: { x: 1, y: 6 } // -2\vec{a} = (-4, 0)
                    }
                },
                {
                    name: '\\overrightarrow{d}',
                    multiplier: 1.5,
                    color: 'purple',
                    vector: {
                        start: { x: 2, y: 8 },
                        end: { x: 5, y: 8 } // 1.5\vec{a} = (3, 0)
                    }
                },
                {
                    name: '\\overrightarrow{f}',
                    multiplier: -0.5,
                    color: 'orange',
                    vector: {
                        start: { x: 2, y: 9 },
                        end: { x: 1, y: 9 } // -0.5\vec{a} = (-1, 0)
                    }
                }
            ],
            multiplier: 1.5, // Відповідь: \vec{d}
            correctVectorName: '\\overrightarrow{d}'
        },
        // Приклад 7: Відповідь -1.5\vec{a} = \vec{f}
        {
            vectorA: {
                start: { x: 3, y: 2 },
                end: { x: 5, y: 2 } // \vec{a} = (2, 0)
            },
            vectors: [
                {
                    name: '\\overrightarrow{b}',
                    multiplier: 0.5,
                    color: 'green',
                    vector: {
                        start: { x: 6, y: 4 },
                        end: { x: 7, y: 4 } // 0.5\vec{a} = (1, 0)
                    }
                },
                {
                    name: '\\overrightarrow{c}',
                    multiplier: -2,
                    color: 'blue',
                    vector: {
                        start: { x: 5, y: 6 },
                        end: { x: 1, y: 6 } // -2\vec{a} = (-4, 0)
                    }
                },
                {
                    name: '\\overrightarrow{d}',
                    multiplier: 2,
                    color: 'purple',
                    vector: {
                        start: { x: 2, y: 8 },
                        end: { x: 6, y: 8 } // 2\vec{a} = (4, 0)
                    }
                },
                {
                    name: '\\overrightarrow{f}',
                    multiplier: -1.5,
                    color: 'orange',
                    vector: {
                        start: { x: 2, y: 9 },
                        end: { x: -1, y: 9 } // -1.5\vec{a} = (-3, 0)
                    }
                }
            ],
            multiplier: -1.5, // Відповідь: \vec{f}
            correctVectorName: '\\overrightarrow{f}'
        }
    ];

    // Випадковий вибір прикладу
    const selectedExample = examples[Math.floor(Math.random() * examples.length)];
    
    // Створюємо масив відповідей
    const answers = selectedExample.vectors.map(v => v.name);
    const originalVectors = [...selectedExample.vectors]; // Зберігаємо оригінальний порядок
    const shuffledAnswers = shuffle([...answers]); // Перемішуємо відповіді
    
    // Знаходимо правильний індекс після перемішування
    const correctIndex = shuffledAnswers.indexOf(selectedExample.correctVectorName);

    console.log('Generated vector multiple question:', {
        vectorA: `from (${selectedExample.vectorA.start.x}, ${selectedExample.vectorA.start.y}) to (${selectedExample.vectorA.end.x}, ${selectedExample.vectorA.end.y})`,
        multiplier: selectedExample.multiplier,
        correctAnswer: selectedExample.correctVectorName,
        correctIndex: correctIndex,
        answers: shuffledAnswers,
        vectors: selectedExample.vectors.map(v => ({
            name: v.name,
            start: `(${v.vector.start.x}, ${v.vector.start.y})`,
            end: `(${v.vector.end.x}, ${v.vector.end.y})`,
            color: v.color
        }))
    });

    return {
        question: `На сітці зображено вектор \\(\\vec{a}\\) та вектори \\(\\overrightarrow{b}\\), \\(\\overrightarrow{c}\\), \\(\\overrightarrow{d}\\), \\(\\overrightarrow{f}\\). Який із векторів відповідає \\(${selectedExample.multiplier}\\vec{a}\\)?`,
        vectorA: selectedExample.vectorA,
        vectors: originalVectors, // Повертаємо вектори в оригінальному порядку для відображення
        answers: shuffledAnswers, // Перемішані відповіді для кнопок
        correct: correctIndex // Правильний індекс після перемішування
    };
}

                        
function drawVectorQuestion() {
    const now = performance.now();
    if (now - lastDrawTime < 50) return;
    lastDrawTime = now;

    const canvas = elements.vectorCanvas;
    if (!canvas) {
        console.error('vectorCanvas is not defined');
        return;
    }
    const ctx = canvas.getContext('2d');
    if (!ctx) {
        console.error('Canvas context is not defined');
        return;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

     if (currentQuestionType === 5) {
        // Код для куба (без змін)
        const vertices = {
            A: [0, 0, 0], B: [1, 0, 0], C: [1, 1, 0], D: [0, 1, 0],
            A1: [0, 0, 1], B1: [1, 0, 1], C1: [1, 1, 1], D1: [0, 1, 1]
        };


        const project = (point) => {
            const scale = 100;
            const xOffset = 75;
            const yOffset = 200;
            const x = point[0] * scale + point[2] * scale * 0.5 + xOffset;
            const y = -point[1] * scale - point[2] * scale * 0.5 + yOffset;
            return [x, y];
        };

        // Малюємо куб
        ctx.beginPath();
        const edges = [
            ['A', 'B'], ['B', 'C'], ['C', 'D'], ['D', 'A'],
            ['A1', 'B1'], ['B1', 'C1'], ['C1', 'D1'], ['D1', 'A1'],
            ['A', 'A1'], ['B', 'B1'], ['C', 'C1'], ['D', 'D1']
        ];
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1.5;
        edges.forEach(([start, end]) => {
            const [x1, y1] = project(vertices[start]);
            const [x2, y2] = project(vertices[end]);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
        });
        ctx.stroke();

        // Малюємо підписи вершин
        ctx.fillStyle = 'yellow';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ['A', 'B', 'C', 'D', 'A1', 'B1', 'C1', 'D1'].forEach(v => {
            const [x, y] = project(vertices[v]);
            if (v === 'A') ctx.fillText(v, x - 10, y + 20);
            else if (v === 'B') ctx.fillText(v, x, y + 20);
            else if (v === 'C') ctx.fillText(v, x + 15, y);
            else if (v === 'D') ctx.fillText(v, x - 15, y);
            else if (v === 'C1') ctx.fillText(v, x + 15, y);
            else if (v === 'D1') ctx.fillText(v, x - 20, y - 5);
            else ctx.fillText(v, x + 15, y - 10);
        });

        // Малюємо вектори з currentQuestion.vectors
        currentQuestion.vectors.forEach(v => {
            ctx.beginPath();
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            const [x1, y1] = project(vertices[v.start]);
            const [x2, y2] = project(vertices[v.end]);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            const angle = Math.atan2(y2 - y1, x2 - x1);
            ctx.lineTo(x2 - 10 * Math.cos(angle - Math.PI / 6), y2 - 10 * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - 10 * Math.cos(angle + Math.PI / 6), y2 - 10 * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        });

        // Малюємо userVectorC.start
        if (userVectorC.start && userVectorC.start.vertex) {
            const [startX, startY] = project(vertices[userVectorC.start.vertex]);
            ctx.beginPath();
            ctx.fillStyle = '#e74c3c';
            ctx.arc(startX, startY, 4, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = 'red';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText('START', startX, startY - 15);
            console.log(`Drawing START at (${startX}, ${startY}) for vertex ${userVectorC.start.vertex}`);
        }

        // Малюємо userVectorC штрихпунктирною лінією
        if (userVectorC.start && userVectorC.end && userVectorC.start.vertex && userVectorC.end.vertex) {
            const [x1, y1] = project(vertices[userVectorC.start.vertex]);
            const [x2, y2] = project(vertices[userVectorC.end.vertex]);
            ctx.beginPath();
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const arrowLength = 12;
            ctx.lineTo(x2 - arrowLength * Math.cos(angle - Math.PI / 4), y2 - arrowLength * Math.sin(angle - Math.PI / 4));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - arrowLength * Math.cos(angle + Math.PI / 4), y2 - arrowLength * Math.sin(angle + Math.PI / 4));
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.beginPath();
            ctx.fillStyle = '#e74c3c';
            ctx.arc(x1, y1, 4, 0, 2 * Math.PI);
            ctx.arc(x2, y2, 4, 0, 2 * Math.PI);
            ctx.fill();

            // Додаємо підпис для userVectorC
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.sqrt(dx * dx + dy * dy) || 1;
            const offset = 10;
            let offsetX = -dy / len * offset;
            let offsetY = dx / len * offset;
            let labelX = midX + offsetX;
            let labelY = midY + offsetY;

            if (Math.abs(dx) < 0.1) { // Вертикальний
                labelX = midX + offset;
                labelY = midY;
            } else if (Math.abs(dy) < 0.1) { // Горизонтальний
                labelX = midX;
                labelY = midY - offset;
            }

            ctx.fillStyle = 'red';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('c', labelX, labelY);

            const textWidth = ctx.measureText('c').width;
            const arrowY = labelY - 8;
            ctx.beginPath();
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 1;
            ctx.moveTo(labelX - textWidth / 2, arrowY);
            ctx.lineTo(labelX + textWidth / 2, arrowY);
            ctx.lineTo(labelX + textWidth / 2 - 4, arrowY - 4);
            ctx.moveTo(labelX + textWidth / 2, arrowY);
            ctx.lineTo(labelX + textWidth / 2 - 4, arrowY + 4);
            ctx.stroke();

            console.log(`Drawing userVectorC from (${x1}, ${y1}) to (${x2}, ${y2}) with label at (${labelX}, ${labelY})`);
        }
    } else {
        // Встановлюємо розмір canvas для сітки (10x10 або 13x13)
        canvas.width = 300; // Для 10x10
        // canvas.width = 390; // Для 13x13
        canvas.height = canvas.width;
        ctx.fillStyle = '#ecf0f1';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = '#bdc3c7';
        ctx.lineWidth = 0.5;
        const gridSize = 10; // Змінити на 13 для сітки 13x13
        for (let i = 0; i <= gridSize; i++) {
            ctx.beginPath();
            ctx.moveTo(i * 30, 0);
            ctx.lineTo(i * 30, canvas.height);
            ctx.moveTo(0, i * 30);
            ctx.lineTo(canvas.width, i * 30);
            ctx.stroke();
        }

        // Малюємо паралелограм для питання 4
        if (currentQuestionType === 4) {
            const a_dx = vectorA.end.x - vectorA.start.x;
            const a_dy = vectorA.end.y - vectorA.start.y;
            const b_dx = vectorB.end.x - vectorB.start.x;
            const b_dy = vectorB.end.y - vectorB.start.y;

            ctx.beginPath();
            ctx.strokeStyle = '#7f8c8d';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.moveTo(vectorA.end.x * 30, vectorA.end.y * 30);
            ctx.lineTo((vectorA.start.x + a_dx + b_dx) * 30, (vectorA.start.y + a_dy + b_dy) * 30);
            ctx.moveTo(vectorB.end.x * 30, vectorB.end.y * 30);
            ctx.lineTo((vectorA.start.x + a_dx + b_dx) * 30, (vectorA.start.y + a_dy + b_dy) * 30);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.beginPath();
            ctx.fillStyle = '#7f8c8d';
            ctx.arc((vectorA.start.x + a_dx + b_dx) * 30, (vectorA.start.y + a_dy + b_dy) * 30, 4, 0, 2 * Math.PI);
            ctx.fill();
        }

        // Зберігаємо позиції підписів для уникнення перекриття
        const labelPositions = [];

        const drawVector = (vector, label, color = '#2c3e50', dashed = false) => {
            if (!vector || !vector.start || !vector.end || !vector.start.x || !vector.start.y || !vector.end.x || !vector.end.y) {
                console.warn(`Invalid vector for label ${label}:`, vector);
                return;
            }

            const x1 = vector.start.x * 30;
            const y1 = vector.start.y * 30;
            const x2 = vector.end.x * 30;
            const y2 = vector.end.y * 30;

            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            if (dashed) ctx.setLineDash([5, 5]);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const arrowLength = 12;
            ctx.lineTo(x2 - arrowLength * Math.cos(angle - Math.PI / 4), y2 - arrowLength * Math.sin(angle - Math.PI / 4));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - arrowLength * Math.cos(angle + Math.PI / 4), y2 - arrowLength * Math.sin(angle + Math.PI / 4));
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.arc(x1, y1, 4, 0, 2 * Math.PI);
            ctx.arc(x2, y2, 4, 0, 2 * Math.PI);
            ctx.fill();

            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.sqrt(dx * dx + dy * dy) || 1;
            const offset = 10;
            let offsetX = -dy / len * offset;
            let offsetY = dx / len * offset;
            let labelX = midX + offsetX;
            let labelY = midY + offsetY;

            if (Math.abs(dx) < 0.1) {
                offsetX = offset;
                offsetY = 0;
                labelX = midX + offset;
                labelY = midY;
            } else if (Math.abs(dy) < 0.1) {
                offsetX = 0;
                offsetY = -offset;
                labelX = midX;
                labelY = midY - offset;
            }

            for (const pos of labelPositions) {
                const dist = Math.sqrt((labelX - pos.x) ** 2 + (labelY - pos.y) ** 2);
                if (dist < 20) {
                    if (Math.abs(dx) < 0.1) {
                        labelX = midX - offset;
                    } else if (Math.abs(dy) < 0.1) {
                        labelY = midY + offset;
                    } else {
                        offsetX = dy / len * offset;
                        offsetY = -dx / len * offset;
                        labelX = midX + offsetX;
                        labelY = midY + offsetY;
                    }
                    break;
                }
            }

            labelPositions.push({ x: labelX, y: labelY, label });

            let simpleLabel = '';
            if (label === '\\(\\vec{a}\\)' || label === '\\overrightarrow{a}') simpleLabel = 'a';
            else if (label === '\\(\\vec{b}\\)' || label === '\\overrightarrow{b}') simpleLabel = 'b';
            else if (label === '\\(\\vec{c}\\)' || label === '\\overrightarrow{c}') simpleLabel = 'c';
            else if (label === '\\(\\vec{d}\\)' || label === '\\overrightarrow{d}') simpleLabel = 'd';
            else if (label === '\\(\\vec{f}\\)' || label === '\\overrightarrow{f}') simpleLabel = 'f';
            else {
                const match = label.match(/\\vec\{([a-zA-Z])\}|\\overrightarrow\{([a-zA-Z])\}/);
                simpleLabel = match ? (match[1] || match[2]) : 'unknown';
                if (simpleLabel === 'unknown') {
                    console.warn(`Failed to parse label: ${label}`);
                }
            }

            ctx.fillStyle = color;
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(simpleLabel, labelX, labelY);

            const textWidth = ctx.measureText(simpleLabel).width;
            const arrowY = labelY - 8;
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.moveTo(labelX - textWidth / 2, arrowY);
            ctx.lineTo(labelX + textWidth / 2, arrowY);
            ctx.lineTo(labelX + textWidth / 2 - 4, arrowY - 4);
            ctx.moveTo(labelX + textWidth / 2, arrowY);
            ctx.lineTo(labelX + textWidth / 2 - 4, arrowY + 4);
            ctx.stroke();

            console.log(`Drawing label ${simpleLabel} at (${labelX}, ${labelY}) for vector from (${x1}, ${y1}) to (${x2}, ${y2})`);
        };

        if (currentQuestionType === 6) {
            drawVector(vectorA, '\\(\\vec{a}\\)', 'red');
            currentQuestion.vectors.forEach(v => {
                drawVector(v.vector, v.name, v.color, true);
            });
        } else if (vectorA && vectorB) {
            drawVector(vectorA, '\\(\\vec{a}\\)', '#2c3e50');
            drawVector(vectorB, '\\(\\vec{b}\\)', '#2c3e50');
        }

        // Малюємо userVectorC для питань 2, 3, 4
        if (userVectorC.start && !userVectorC.end && currentQuestionType !== 6 && currentQuestionType !== 5) {
            const startX = userVectorC.start.x * 30;
            const startY = userVectorC.start.y * 30;
            ctx.beginPath();
            ctx.fillStyle = '#e74c3c';
            ctx.arc(startX, startY, 4, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = 'red';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText('START', startX, startY - 15);
        }
        if (userVectorC.start && userVectorC.end && currentQuestionType !== 6 && currentQuestionType !== 5) {
            const x1 = userVectorC.start.x * 30;
            const y1 = userVectorC.start.y * 30;
            const x2 = userVectorC.end.x * 30;
            const y2 = userVectorC.end.y * 30;

            ctx.beginPath();
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const arrowLength = 12;
            ctx.lineTo(x2 - arrowLength * Math.cos(angle - Math.PI / 4), y2 - arrowLength * Math.sin(angle - Math.PI / 4));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - arrowLength * Math.cos(angle + Math.PI / 4), y2 - arrowLength * Math.sin(angle + Math.PI / 4));
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.beginPath();
            ctx.fillStyle = '#e74c3c';
            ctx.arc(x1, y1, 4, 0, 2 * Math.PI);
            ctx.arc(x2, y2, 4, 0, 2 * Math.PI);
            ctx.fill();

            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.sqrt(dx * dx + dy * dy) || 1;
            const offset = 10;
            let offsetX = -dy / len * offset;
            let offsetY = dx / len * offset;
            let labelX = midX + offsetX;
            let labelY = midY + offsetY;

            if (Math.abs(dx) < 0.1) {
                labelX = midX + offset;
                labelY = midY;
            } else if (Math.abs(dy) < 0.1) {
                labelX = midX;
                labelY = midY - offset;
            }

            for (const pos of labelPositions) {
                const dist = Math.sqrt((labelX - pos.x) ** 2 + (labelY - pos.y) ** 2);
                if (dist < 20) {
                    if (Math.abs(dx) < 0.1) {
                        labelX = midX - offset;
                    } else if (Math.abs(dy) < 0.1) {
                        labelY = midY + offset;
                    } else {
                        offsetX = dy / len * offset;
                        offsetY = -dx / len * offset;
                        labelX = midX + offsetX;
                        labelY = midY + offsetY;
                    }
                    break;
                }
            }

            labelPositions.push({ x: labelX, y: labelY, label: 'c' });

            ctx.fillStyle = 'red';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('c', labelX, labelY);

            const textWidth = ctx.measureText('c').width;
            const arrowY = labelY - 8;
            ctx.beginPath();
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 1;
            ctx.moveTo(labelX - textWidth / 2, arrowY);
            ctx.lineTo(labelX + textWidth / 2, arrowY);
            ctx.lineTo(labelX + textWidth / 2 - 4, arrowY - 4);
            ctx.moveTo(labelX + textWidth / 2, arrowY);
            ctx.lineTo(labelX + textWidth / 2 - 4, arrowY + 4);
            ctx.stroke();
        }
    }

    console.log('Vector question drawn successfully');
}
            
      function checkCubeVectorSum() {
    if (!userVectorC.start || !userVectorC.end || !currentQuestion.correct) {
        console.warn('checkCubeVectorSum: Incomplete data', {
            start: userVectorC.start,
            end: userVectorC.end,
            correct: currentQuestion.correct
        });
        return false;
    }

    const vertices = {
        A: [0, 0, 0], B: [1, 0, 0], C: [1, 1, 0], D: [0, 1, 0],
        A1: [0, 0, 1], B1: [1, 0, 1], C1: [1, 1, 1], D1: [0, 1, 1]
    };

    const project = (point) => {
        const scale = 100;
        const xOffset = 75;
        const yOffset = 200;
        const x = point[0] * scale + point[2] * scale * 0.5 + xOffset;
        const y = -point[1] * scale - point[2] * scale * 0.5 + yOffset;
        return [x, y];
    };

    const [startX, startY] = project(vertices[currentQuestion.correct.start]);
    const [endX, endY] = project(vertices[currentQuestion.correct.end]);
    const canvasStartX = userVectorC.start.x;
    const canvasStartY = userVectorC.start.y;
    const canvasEndX = userVectorC.end.x;
    const canvasEndY = userVectorC.end.y;

    const threshold = 1.5; // Збільшено поріг чутливості
    const isCorrect = (
        Math.abs(canvasStartX - startX / 30) < threshold &&
        Math.abs(canvasStartY - startY / 30) < threshold &&
        Math.abs(canvasEndX - endX / 30) < threshold &&
        Math.abs(canvasEndY - endY / 30) < threshold
    );

    console.log('Checking cube vector sum:', {
        userStart: [canvasStartX, canvasStartY],
        userEnd: [canvasEndX, canvasEndY],
        correctStart: [startX / 30, startY / 30],
        correctEnd: [endX / 30, endY / 30],
        isCorrect
    });

    return isCorrect;
}

function handleCanvasClick(event) {
    if (currentQuestionType !== 2 && currentQuestionType !== 3 && currentQuestionType !== 4 && currentQuestionType !== 5) return;
    if (!elements.vectorCanvas) {
        console.error('vectorCanvas is not defined');
        return;
    }

    const rect = elements.vectorCanvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    const thresholdPixel = 15; // Збільшено поріг у пікселях для питання 5

    console.log(`Click at canvas: (${x}, ${y})`);

    if (currentQuestionType === 5) {
        const vertices = {
            A: [0, 0, 0], B: [1, 0, 0], C: [1, 1, 0], D: [0, 1, 0],
            A1: [0, 0, 1], B1: [1, 0, 1], C1: [1, 1, 1], D1: [0, 1, 1]
        };

        const project = (point) => {
            const scale = 100;
            const xOffset = 75;
            const yOffset = 200;
            const x = point[0] * scale + point[2] * scale * 0.5 + xOffset;
            const y = -point[1] * scale - point[2] * scale * 0.5 + yOffset;
            return [x, y];
        };

        let closestVertex = null;
        let minDistance = Infinity;
        Object.keys(vertices).forEach(v => {
            const [vx, vy] = project(vertices[v]);
            const distance = Math.sqrt((x - vx) ** 2 + (y - vy) ** 2);
            if (distance < minDistance && distance < thresholdPixel) {
                minDistance = distance;
                closestVertex = v;
            }
        });

        if (!closestVertex) {
            console.log('No vertex selected for question 5');
            return;
        }

        const [canvasX, canvasY] = project(vertices[closestVertex]);
        const gridVertexX = canvasX / 30;
        const gridVertexY = canvasY / 30;

        if (!userVectorC.start) {
            userVectorC.start = { x: gridVertexX, y: gridVertexY, vertex: closestVertex };
            userVectorC.end = null;
            console.log(`Selected start for question 5: ${closestVertex} at (${gridVertexX}, ${gridVertexY})`);
            drawVectorQuestion();
        } else {
            userVectorC.end = { x: gridVertexX, y: gridVertexY, vertex: closestVertex };
            elements.submitAnswerBtn.disabled = false;
            elements.submitAnswerBtn.classList.add('active');
            console.log(`Selected end for question 5: ${closestVertex} at (${gridVertexX}, ${gridVertexY})`);
            drawVectorQuestion();
        }
    } else {
        const gridX = Math.round(x / 30);
        const gridY = Math.round(y / 30);
        const thresholdGrid = 1.0;

        if (!userVectorC.start) {
            let selected = false;
            if (currentQuestionType === 2) {
                console.log(`Checking for question 2: vectorA.start=(${vectorA?.start?.x}, ${vectorA?.start?.y}), vectorB.end=(${vectorB?.end?.x}, ${vectorB?.end?.y})`);
                if (
                    (vectorA && Math.abs(gridX - vectorA.start.x) < thresholdGrid && Math.abs(gridY - vectorA.start.y) < thresholdGrid) ||
                    (vectorB && Math.abs(gridX - vectorB.end.x) < thresholdGrid && Math.abs(gridY - vectorB.end.y) < thresholdGrid)
                ) {
                    userVectorC.start = { x: gridX, y: gridY };
                    userVectorC.end = null;
                    selected = true;
                    console.log(`Selected start for question 2 at (${gridX}, ${gridY})`);
                }
            } else if (currentQuestionType === 3) {
                console.log(`Checking for question 3: vectorA.end=(${vectorA?.end?.x}, ${vectorA?.end?.y}), vectorB.end=(${vectorB?.end?.x}, ${vectorB?.end?.y})`);
                if (
                    (vectorB && Math.abs(gridX - vectorB.end.x) < thresholdGrid && Math.abs(gridY - vectorB.end.y) < thresholdGrid) ||
                    (vectorA && Math.abs(gridX - vectorA.end.x) < thresholdGrid && Math.abs(gridY - vectorA.end.y) < thresholdGrid)
                ) {
                    userVectorC.start = { x: gridX, y: gridY };
                    userVectorC.end = null;
                    selected = true;
                    console.log(`Selected start for question 3 at (${gridX}, ${gridY})`);
                }
            } else if (currentQuestionType === 4) {
                const a_dx = vectorA.end.x - vectorA.start.x;
                const a_dy = vectorA.end.y - vectorA.start.y;
                const b_dx = vectorB.end.x - vectorB.start.x;
                const b_dy = vectorB.end.y - vectorB.start.y;
                const oppositeVertexX = vectorA.start.x + a_dx + b_dx;
                const oppositeVertexY = vectorA.start.y + a_dy + b_dy;

                console.log(`Checking for question 4: vectorA.start=(${vectorA?.start?.x}, ${vectorA?.start?.y}), vectorA.end=(${vectorA?.end?.x}, ${vectorA?.end?.y}), vectorB.end=(${vectorB?.end?.x}, ${vectorB?.end?.y}), opposite=(${oppositeVertexX}, ${oppositeVertexY})`);
                if (
                    (vectorA && Math.abs(gridX - vectorA.start.x) < thresholdGrid && Math.abs(gridY - vectorA.start.y) < thresholdGrid) ||
                    (vectorA && Math.abs(gridX - vectorA.end.x) < thresholdGrid && Math.abs(gridY - vectorA.end.y) < thresholdGrid) ||
                    (vectorB && Math.abs(gridX - vectorB.end.x) < thresholdGrid && Math.abs(gridY - vectorB.end.y) < thresholdGrid) ||
                    (Math.abs(gridX - oppositeVertexX) < thresholdGrid && Math.abs(gridY - oppositeVertexY) < thresholdGrid)
                ) {
                    userVectorC.start = { x: gridX, y: gridY };
                    userVectorC.end = null;
                    selected = true;
                    console.log(`Selected start for question 4 at (${gridX}, ${gridY})`);
                }
            }
            if (selected) {
                drawVectorQuestion();
            } else {
                console.log(`No valid start point selected for question ${currentQuestionType} at (${gridX}, ${gridY})`);
            }
        } else {
            userVectorC.end = { x: gridX, y: gridY };
            elements.submitAnswerBtn.disabled = false;
            elements.submitAnswerBtn.classList.add('active');
            console.log(`Selected end for question ${currentQuestionType} at (${gridX}, ${gridY})`);
            drawVectorQuestion();
        }
    }
}
function handleMouseDown(event) {
    // Вектори нерухомі
}

function handleMouseMove(event) {
    // Вектори нерухомі
}

function handleMouseUp() {
    // Вектори нерухомі
}

function checkVectorSum() {
    if (!vectorA || !vectorB || !userVectorC.start || !userVectorC.end) {
        return false;
    }
    const isCorrect = (
        Math.abs(userVectorC.start.x - vectorA.start.x) < 0.75 &&
        Math.abs(userVectorC.start.y - vectorA.start.y) < 0.75 &&
        Math.abs(userVectorC.end.x - vectorB.end.x) < 0.75 &&
        Math.abs(userVectorC.end.y - vectorB.end.y) < 0.75
    );
    return isCorrect;
}

 function checkVectorDifference() {
    if (!vectorA || !vectorB || !userVectorC.start || !userVectorC.end) {
        return false;
    }
    // Для \(\vec{c} = \vec{a} - \vec{b}\), вектор \(\vec{c}\) йде від кінця \(\vec{b}\) до кінця \(\vec{a}\)
    const isCorrect = (
        Math.abs(userVectorC.start.x - vectorB.end.x) < 0.75 &&
        Math.abs(userVectorC.start.y - vectorB.end.y) < 0.75 &&
        Math.abs(userVectorC.end.x - vectorA.end.x) < 0.75 &&
        Math.abs(userVectorC.end.y - vectorA.end.y) < 0.75
    );
    return isCorrect;
}

function checkVectorParallelogram() {
    if (!vectorA || !vectorB || !userVectorC.start || !userVectorC.end) {
        return false;
    }
    // Для \(\vec{c} = \vec{a} + \vec{b}\) за правилом паралелограма:
    // Початок \(\vec{c}\) збігається з початком \(\vec{a}\) і \(\vec{b}\),
    // Кінець \(\vec{c}\) знаходиться в точці (vectorA.start.x + a_dx + b_dx, vectorA.start.y + a_dy + b_dy)
    const a_dx = vectorA.end.x - vectorA.start.x;
    const a_dy = vectorA.end.y - vectorA.start.y;
    const b_dx = vectorB.end.x - vectorB.start.x;
    const b_dy = vectorB.end.y - vectorB.start.y;
    const correctEndX = vectorA.start.x + a_dx + b_dx;
    const correctEndY = vectorA.start.y + a_dy + b_dy;

    const isCorrect = (
        Math.abs(userVectorC.start.x - vectorA.start.x) < 0.75 &&
        Math.abs(userVectorC.start.y - vectorA.start.y) < 0.75 &&
        Math.abs(userVectorC.end.x - correctEndX) < 0.75 &&
        Math.abs(userVectorC.end.y - correctEndY) < 0.75
    );
    return isCorrect;
}

function displayQuestion() {
    if (!currentQuestion) {
        console.error('currentQuestion is null');
        return;
    }

    console.log('Displaying question type:', currentQuestionType);
    elements.questionCircle.style.display = 'flex';
    elements.questionNumber.textContent = `Питання ${currentQuestionType}`;
    elements.questionText.innerHTML = currentQuestion.question || 'Помилка: питання не завантажено';
    elements.submitAnswerBtn.disabled = true;
    elements.submitAnswerBtn.classList.remove('active');
    elements.resultMessage.style.opacity = '0';
    elements.resultMessage.className = 'result-message';
    elements.completionMessage.style.display = 'none';
    elements.questionText.style.display = 'block';

    const canvasContainer = elements.vectorCanvas ? (elements.vectorCanvas.parentElement || document.body) : document.body;
    const existingLabels = canvasContainer.querySelectorAll('[id^="vector-label-"]');
    existingLabels.forEach(label => label.remove());

    if (currentQuestionType === 1) {
        elements.matrixText.style.display = 'block';
        elements.vectorCanvas.style.display = 'none';
        elements.answerOptions.style.display = 'grid';
        elements.submitAnswerBtn.style.display = 'block';

        elements.matrixText.innerHTML = currentQuestion.canvas ?
            `<img src="${currentQuestion.canvas}" alt="Куб із векторами" aria-describedby="questionText" style="max-width: 100%; display: block;">` :
            'Помилка: зображення куба не завантажено';

        const answerButtons = elements.trainerModal.querySelectorAll('.answer-button');
        answerButtons.forEach((btn, index) => {
            btn.innerHTML = currentQuestion.answers && currentQuestion.answers[index] ?
                `\\(${currentQuestion.answers[index]}\\)` : `Варіант ${index + 1}`;
            btn.setAttribute('data-answer', index);
            btn.classList.remove('selected', 'correct', 'wrong');
            btn.disabled = false;
        });
    } else if (currentQuestionType === 6) {
        elements.matrixText.style.display = 'none';
        elements.vectorCanvas.style.display = 'block';
        elements.answerOptions.style.display = 'grid';
        elements.submitAnswerBtn.style.display = 'block';

        const answerButtons = elements.trainerModal.querySelectorAll('.answer-button');
        answerButtons.forEach((btn, index) => {
            btn.innerHTML = currentQuestion.answers && currentQuestion.answers[index] ?
                `\\(${currentQuestion.answers[index]}\\)` : `Варіант ${index + 1}`;
            btn.setAttribute('data-answer', index);
            btn.classList.remove('selected', 'correct', 'wrong');
            btn.disabled = false;
        });

        drawVectorQuestion();
    } else {
        elements.matrixText.style.display = 'none';
        elements.vectorCanvas.style.display = 'block';
        elements.answerOptions.style.display = 'none';
        elements.submitAnswerBtn.style.display = 'block';
        drawVectorQuestion();
    }

    if (window.MathJax && MathJax.typesetPromise) {
        setTimeout(() => {
            const typesetElements = currentQuestionType === 1 || currentQuestionType === 6 ?
                [elements.questionText, elements.matrixText, ...elements.trainerModal.querySelectorAll('.answer-button')] :
                [elements.questionText, canvasContainer];
            console.log('MathJax typeset elements:', typesetElements.map(el => el.id || el.tagName));
            MathJax.typesetPromise(typesetElements).then(() => {
                console.log('MathJax rendered successfully for question type:', currentQuestionType);
                if (currentQuestionType === 1 || currentQuestionType === 6) {
                    const firstButton = elements.trainerModal.querySelector('.answer-button');
                    if (firstButton) firstButton.focus();
                } else {
                    elements.vectorCanvas.focus();
                }
            }).catch(err => {
                console.error('MathJax rendering failed:', err);
                if (currentQuestionType === 1 || currentQuestionType === 6) {
                    const firstButton = elements.trainerModal.querySelector('.answer-button');
                    if (firstButton) firstButton.focus();
                } else {
                    elements.vectorCanvas.focus();
                }
            });
        }, 100);
    } else {
        console.warn('MathJax не завантажено');
        if (currentQuestionType === 1 || currentQuestionType === 6) {
            elements.trainerModal.querySelectorAll('.answer-button').forEach((btn, index) => {
                btn.textContent = currentQuestion.answers && currentQuestion.answers[index] ?
                    currentQuestion.answers[index].replace(/\\overrightarrow\{([A-Za-z1-9_]+)\}/g, '$1') : `Варіант ${index + 1}`;
            });
        }
        if (currentQuestionType === 6) {
            elements.questionText.textContent = currentQuestion.question.replace(/\\overrightarrow\{([A-Za-z1-9_]+)\}/g, '$1');
        }
    }
}
// Обробники подій для кнопок відповідей
if (elements.trainerModal) {
    elements.trainerModal.querySelectorAll('.answer-button').forEach(button => {
        button.addEventListener('click', () => {
            if (currentQuestionType !== 1 && currentQuestionType !== 6) return;
            elements.trainerModal.querySelectorAll('.answer-button').forEach(btn => btn.classList.remove('selected'));
            button.classList.add('selected');
            selectedAnswer = parseInt(button.getAttribute('data-answer'));
            elements.submitAnswerBtn.disabled = false;
            elements.submitAnswerBtn.classList.add('active');
            console.log('Selected Answer:', selectedAnswer);
        });
        
        button.addEventListener('keydown', e => {
            if (currentQuestionType !== 1 && currentQuestionType !== 6) return;
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                elements.trainerModal.querySelectorAll('.answer-button').forEach(btn => btn.classList.remove('selected'));
                button.classList.add('selected');
                selectedAnswer = parseInt(button.getAttribute('data-answer'));
                elements.submitAnswerBtn.disabled = false;
                elements.submitAnswerBtn.classList.add('active');
                console.log('Selected Answer (key):', selectedAnswer);
            }
        });
    });
}

// Обробники подій для canvas
if (elements.vectorCanvas) {
    elements.vectorCanvas.addEventListener('mousedown', handleMouseDown);
    elements.vectorCanvas.addEventListener('mousemove', handleMouseMove);
    elements.vectorCanvas.addEventListener('mouseup', handleMouseUp);
    elements.vectorCanvas.addEventListener('mouseleave', handleMouseUp);
    elements.vectorCanvas.addEventListener('click', handleCanvasClick);
}

// Обробник кнопки Submit
if (elements.submitAnswerBtn) {
    elements.submitAnswerBtn.addEventListener('click', () => {
        if (currentQuestionType === 1) {
            if (selectedAnswer === null || elements.submitAnswerBtn.disabled) {
                console.warn('Submit button clicked but no answer selected or button disabled');
                return;
            }

            const isCorrect = selectedAnswer === currentQuestion.correct;
            console.log('Question 1 - isCorrect:', isCorrect, 'Selected:', selectedAnswer, 'Correct:', currentQuestion.correct);

            elements.resultMessage.textContent = isCorrect ? '✓ Правильно! Молодець!' : '✗ Неправильно. Спробуй ще раз!';
            elements.resultMessage.className = `result-message ${isCorrect ? 'correct' : 'wrong'}`;
            elements.resultMessage.style.display = 'block';
            elements.resultMessage.style.opacity = '1';

            elements.trainerModal.querySelectorAll('.answer-button').forEach(btn => {
                btn.disabled = true;
                const btnIndex = parseInt(btn.getAttribute('data-answer'));
                if (btnIndex === currentQuestion.correct) {
                    btn.classList.add('correct');
                } else if (btnIndex === selectedAnswer) {
                    btn.classList.add('wrong');
                }
            });

            setTimeout(() => {
                elements.resultMessage.style.opacity = '0';
                setTimeout(() => {
                    elements.resultMessage.style.display = 'none';
                    if (isCorrect) {
                        currentQuestionType = 2;
                        currentQuestion = generateVectorQuestion();
                        vectorA = currentQuestion.vectorA;
                        vectorB = currentQuestion.vectorB;
                        selectedAnswer = null;
                        userVectorC = { start: null, end: null };
                        displayQuestion();
                    } else {
                        currentQuestion = generateCubeQuestion();
                        selectedAnswer = null;
                        displayQuestion();
                    }
                }, 500);
            }, 3000);
        } else if (currentQuestionType === 2) {
            if (!userVectorC.start || !userVectorC.end || elements.submitAnswerBtn.disabled) {
                console.warn('Submit button clicked but vectorC incomplete or button disabled');
                return;
            }

            const isCorrect = checkVectorSum();
            elements.resultMessage.textContent = isCorrect ? '✓ Правильно! Молодець!' : '✗ Неправильно. Спробуй ще раз!';
            elements.resultMessage.className = `result-message ${isCorrect ? 'correct' : 'wrong'}`;
            elements.resultMessage.style.display = 'block';
            elements.resultMessage.style.opacity = '1';

            const ctx = elements.vectorCanvas.getContext('2d');
            drawVectorQuestion(); // Перемальовуємо canvas із векторами a, b
            if (userVectorC.start && userVectorC.end) {
                const x1 = userVectorC.start.x * 30;
                const y1 = userVectorC.start.y * 30;
                const x2 = userVectorC.end.x * 30;
                const y2 = userVectorC.end.y * 30;

                ctx.beginPath();
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.setLineDash([]);
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const arrowLength = 12;
                ctx.lineTo(x2 - arrowLength * Math.cos(angle - Math.PI / 4), y2 - arrowLength * Math.sin(angle - Math.PI / 4));
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - arrowLength * Math.cos(angle + Math.PI / 4), y2 - arrowLength * Math.sin(angle + Math.PI / 4));
                ctx.stroke();

                ctx.beginPath();
                ctx.fillStyle = '#e74c3c';
                ctx.arc(x1, y1, 4, 0, 2 * Math.PI);
                ctx.arc(x2, y2, 4, 0, 2 * Math.PI);
                ctx.fill();

                console.log(`Drawing userVectorC after check: (${x1}, ${y1}) to (${x2}, ${y2}) without label`);
            }

            setTimeout(() => {
                elements.resultMessage.style.opacity = '0';
                setTimeout(() => {
                    elements.resultMessage.style.display = 'none';
                    if (isCorrect) {
                        currentQuestionType = 3;
                        currentQuestion = generateVectorDifferenceQuestion();
                        vectorA = currentQuestion.vectorA;
                        vectorB = currentQuestion.vectorB;
                        userVectorC = { start: null, end: null };
                        displayQuestion();
                    } else {
                        currentQuestion = generateVectorQuestion();
                        vectorA = currentQuestion.vectorA;
                        vectorB = currentQuestion.vectorB;
                        userVectorC = { start: null, end: null };
                        elements.submitAnswerBtn.disabled = true;
                        elements.submitAnswerBtn.classList.remove('active');
                        displayQuestion();
                    }
                }, 500);
            }, 3000);
        } else if (currentQuestionType === 3) {
            if (!userVectorC.start || !userVectorC.end || elements.submitAnswerBtn.disabled) {
                console.warn('Submit button clicked but vectorC incomplete or button disabled');
                return;
            }

            const isCorrect = checkVectorDifference();
            elements.resultMessage.textContent = isCorrect ? '✓ Правильно! Молодець!' : '✗ Неправильно. Спробуй ще раз!';
            elements.resultMessage.className = `result-message ${isCorrect ? 'correct' : 'wrong'}`;
            elements.resultMessage.style.display = 'block';
            elements.resultMessage.style.opacity = '1';

            const ctx = elements.vectorCanvas.getContext('2d');
            drawVectorQuestion();
            if (userVectorC.start && userVectorC.end) {
                const x1 = userVectorC.start.x * 30;
                const y1 = userVectorC.start.y * 30;
                const x2 = userVectorC.end.x * 30;
                const y2 = userVectorC.end.y * 30;

                ctx.beginPath();
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.setLineDash([]);
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const arrowLength = 12;
                ctx.lineTo(x2 - arrowLength * Math.cos(angle - Math.PI / 4), y2 - arrowLength * Math.sin(angle - Math.PI / 4));
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - arrowLength * Math.cos(angle + Math.PI / 4), y2 - arrowLength * Math.sin(angle + Math.PI / 4));
                ctx.stroke();

                ctx.beginPath();
                ctx.fillStyle = '#e74c3c';
                ctx.arc(x1, y1, 4, 0, 2 * Math.PI);
                ctx.arc(x2, y2, 4, 0, 2 * Math.PI);
                ctx.fill();

                console.log(`Drawing userVectorC after check: (${x1}, ${y1}) to (${x2}, ${y2}) without label`);
            }

            setTimeout(() => {
                elements.resultMessage.style.opacity = '0';
                setTimeout(() => {
                    elements.resultMessage.style.display = 'none';
                    if (isCorrect) {
                        currentQuestionType = 4;
                        currentQuestion = generateVectorParallelogramQuestion();
                        vectorA = currentQuestion.vectorA;
                        vectorB = currentQuestion.vectorB;
                        userVectorC = { start: null, end: null };
                        displayQuestion();
                    } else {
                        currentQuestion = generateVectorDifferenceQuestion();
                        vectorA = currentQuestion.vectorA;
                        vectorB = currentQuestion.vectorB;
                        userVectorC = { start: null, end: null };
                        elements.submitAnswerBtn.disabled = true;
                        elements.submitAnswerBtn.classList.remove('active');
                        displayQuestion();
                    }
                }, 500);
            }, 3000);
        } else if (currentQuestionType === 4) {
            if (!userVectorC.start || !userVectorC.end || elements.submitAnswerBtn.disabled) {
                console.warn('Submit button clicked but vectorC incomplete or button disabled');
                return;
            }

            const isCorrect = checkVectorParallelogram();
            elements.resultMessage.textContent = isCorrect ? '✓ Правильно! Молодець!' : '✗ Неправильно. Спробуй ще раз!';
            elements.resultMessage.className = `result-message ${isCorrect ? 'correct' : 'wrong'}`;
            elements.resultMessage.style.display = 'block';
            elements.resultMessage.style.opacity = '1';

            const ctx = elements.vectorCanvas.getContext('2d');
            drawVectorQuestion();
            if (userVectorC.start && userVectorC.end) {
                const x1 = userVectorC.start.x * 30;
                const y1 = userVectorC.start.y * 30;
                const x2 = userVectorC.end.x * 30;
                const y2 = userVectorC.end.y * 30;

                ctx.beginPath();
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.setLineDash([]);
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const arrowLength = 12;
                ctx.lineTo(x2 - arrowLength * Math.cos(angle - Math.PI / 4), y2 - arrowLength * Math.sin(angle - Math.PI / 4));
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - arrowLength * Math.cos(angle + Math.PI / 4), y2 - arrowLength * Math.sin(angle + Math.PI / 4));
                ctx.stroke();

                ctx.beginPath();
                ctx.fillStyle = '#e74c3c';
                ctx.arc(x1, y1, 4, 0, 2 * Math.PI);
                ctx.arc(x2, y2, 4, 0, 2 * Math.PI);
                ctx.fill();

                console.log(`Drawing userVectorC after check: (${x1}, ${y1}) to (${x2}, ${y2}) without label`);
            }

            setTimeout(() => {
                elements.resultMessage.style.opacity = '0';
                setTimeout(() => {
                    elements.resultMessage.style.display = 'none';
                    if (isCorrect) {
                        currentQuestionType = 5;
                        currentQuestion = generateCubeVectorSumQuestion();
                        vectorA = null;
                        vectorB = null;
                        userVectorC = { start: null, end: null };
                        displayQuestion();
                    } else {
                        currentQuestion = generateVectorParallelogramQuestion();
                        vectorA = currentQuestion.vectorA;
                        vectorB = currentQuestion.vectorB;
                        userVectorC = { start: null, end: null };
                        elements.submitAnswerBtn.disabled = true;
                        elements.submitAnswerBtn.classList.remove('active');
                        displayQuestion();
                    }
                }, 500);
            }, 3000);
        } else if (currentQuestionType === 5) {
            if (!userVectorC.start || !userVectorC.end || elements.submitAnswerBtn.disabled) {
                console.warn('Submit button clicked but vectorC incomplete or button disabled');
                return;
            }

            const isCorrect = checkCubeVectorSum();
            elements.resultMessage.textContent = isCorrect ? '✓ Правильно! Молодець!' : '✗ Неправильно. Спробуй ще раз!';
            elements.resultMessage.className = `result-message ${isCorrect ? 'correct' : 'wrong'}`;
            elements.resultMessage.style.display = 'block';
            elements.resultMessage.style.opacity = '1';

            const ctx = elements.vectorCanvas.getContext('2d');
            drawVectorQuestion(); // Перемальовуємо куб і вектори
            if (userVectorC.start && userVectorC.end && userVectorC.start.vertex && userVectorC.end.vertex) {
                const vertices = {
                    A: [0, 0, 0], B: [1, 0, 0], C: [1, 1, 0], D: [0, 1, 0],
                    A1: [0, 0, 1], B1: [1, 0, 1], C1: [1, 1, 1], D1: [0, 1, 1]
                };
                const project = (point) => {
                    const scale = 100;
                    const xOffset = 75;
                    const yOffset = 200;
                    const x = point[0] * scale + point[2] * scale * 0.5 + xOffset;
                    const y = -point[1] * scale - point[2] * scale * 0.5 + yOffset;
                    return [x, y];
                };
                const [x1, y1] = project(vertices[userVectorC.start.vertex]);
                const [x2, y2] = project(vertices[userVectorC.end.vertex]);

                ctx.beginPath();
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.setLineDash([]);
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const arrowLength = 12;
                ctx.lineTo(x2 - arrowLength * Math.cos(angle - Math.PI / 4), y2 - arrowLength * Math.sin(angle - Math.PI / 4));
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - arrowLength * Math.cos(angle + Math.PI / 4), y2 - arrowLength * Math.sin(angle + Math.PI / 4));
                ctx.stroke();

                ctx.beginPath();
                ctx.fillStyle = '#e74c3c';
                ctx.arc(x1, y1, 4, 0, 2 * Math.PI);
                ctx.arc(x2, y2, 4, 0, 2 * Math.PI);
                ctx.fill();

                console.log(`Drawing userVectorC after check: (${x1}, ${y1}) to (${x2}, ${y2}) without label`);
            }

            setTimeout(() => {
                elements.resultMessage.style.opacity = '0';
                setTimeout(() => {
                    elements.resultMessage.style.display = 'none';
                    if (isCorrect) {
                        currentQuestionType = 6;
                        currentQuestion = generateVectorMultipleQuestion();
                        vectorA = currentQuestion.vectorA;
                        vectorB = null;
                        userVectorC = { start: null, end: null };
                        selectedAnswer = null;
                        displayQuestion();
                    } else {
                        const nextGroupIndex = (currentQuestion.groupIndex + 1) % 8;
                        currentQuestion = generateCubeVectorSumQuestion(nextGroupIndex);
                        userVectorC = { start: null, end: null };
                        elements.submitAnswerBtn.disabled = true;
                        elements.submitAnswerBtn.classList.remove('active');
                        displayQuestion();
                    }
                }, 500);
            }, 3000);
        } else if (currentQuestionType === 6) {
            console.log('Processing question 6 submit. Selected answer:', selectedAnswer, 'Correct answer:', currentQuestion.correct, 'Answers:', currentQuestion.answers);
            if (selectedAnswer === null || selectedAnswer === undefined || isNaN(selectedAnswer) || elements.submitAnswerBtn.disabled) {
                console.warn('Submit button clicked but no valid answer selected or button disabled', {
                    selectedAnswer,
                    buttonDisabled: elements.submitAnswerBtn.disabled
                });
                return;
            }
            

    const isCorrect = selectedAnswer === currentQuestion.correct;

    // Додаткова перевірка для діагностики
    const selectedVectorName = currentQuestion.answers[selectedAnswer];
    const correctVectorName = currentQuestion.answers[currentQuestion.correct];
    const selectedVector = currentQuestion.vectors.find(v => v.name === selectedVectorName);
    const a_dx = vectorA.end.x - vectorA.start.x;
    const a_dy = vectorA.end.y - vectorA.start.y;
    const v_dx = selectedVector ? (selectedVector.vector.end.x - selectedVector.vector.start.x) : 0;
    const v_dy = selectedVector ? (selectedVector.vector.end.y - selectedVector.vector.start.y) : 0;
    const expectedMultiplier = currentQuestion.vectors[currentQuestion.correct].multiplier;

    console.log('Question 6 - Checking answer:', {
        selectedAnswer,
        selectedVectorName,
        correctIndex: currentQuestion.correct,
        correctVectorName,
        selectedVector: selectedVector ? { dx: v_dx.toFixed(2), dy: v_dy.toFixed(2) } : 'undefined',
        expected: { dx: (expectedMultiplier * a_dx).toFixed(2), dy: (expectedMultiplier * a_dy).toFixed(2) },
        isCorrect
    });

    elements.resultMessage.textContent = isCorrect ? '✓ Правильно! Молодець!' : '✗ Неправильно. Спробуй ще раз!';
    elements.resultMessage.className = `result-message ${isCorrect ? 'correct' : 'wrong'}`;
    elements.resultMessage.style.display = 'block';
    elements.resultMessage.style.opacity = '1';

    elements.trainerModal.querySelectorAll('.answer-button').forEach(btn => {
        btn.disabled = true;
        const btnIndex = parseInt(btn.getAttribute('data-answer'));
        if (btnIndex === currentQuestion.correct) {
            btn.classList.add('correct');
        } else if (btnIndex === selectedAnswer) {
            btn.classList.add('wrong');
        }
    });

    setTimeout(() => {
        elements.resultMessage.style.opacity = '0';
        setTimeout(() => {
            elements.resultMessage.style.display = 'none';
            const canvasContainer = elements.vectorCanvas.parentElement || document.body;
            canvasContainer.querySelectorAll('[id^="vector-label-"]').forEach(label => label.remove());
            if (isCorrect) {
                elements.questionCircle.style.display = 'none';
                elements.questionText.style.display = 'none';
                elements.vectorCanvas.style.display = 'none';
                elements.submitAnswerBtn.style.display = 'none';
                elements.matrixText.style.display = 'none';
                elements.matrixText.innerHTML = '';
                elements.answerOptions.style.display = 'none';
                elements.completionMessage.style.display = 'block';
                elements.resetTrainerBtn.focus();
            } else {
                currentQuestion = generateVectorMultipleQuestion();
                vectorA = currentQuestion.vectorA;
                vectorB = null;
                selectedAnswer = null;
                displayQuestion();
            }
        }, 500);
    }, 3000);
}
    });
}
// Обробник кнопки Reset
if (elements.resetTrainerBtn) {
    elements.resetTrainerBtn.addEventListener('click', () => {
        const canvasContainer = elements.vectorCanvas ? (elements.vectorCanvas.parentElement || document.body) : document.body;
        const existingLabels = canvasContainer.querySelectorAll('[id^="vector-label-"]');
        existingLabels.forEach(label => label.remove());
        
        // Скидання до початкового стану
        currentQuestionType = 1;
        currentQuestion = generateCubeQuestion();
        selectedAnswer = null;
        userVectorC = { start: null, end: null };
        vectorA = null;
        vectorB = null;
        
        elements.answerOptions.style.display = 'grid';
        elements.submitAnswerBtn.style.display = 'block';
        elements.completionMessage.style.display = 'none';
        elements.vectorCanvas.style.display = 'none';
        elements.matrixText.style.display = 'block';
        displayQuestion();
    });
}

// Ініціалізація
console.log('Initializing trainer...');
currentQuestion = generateCubeQuestion();
displayQuestion();
           });
    </script>
</body>
</html>


